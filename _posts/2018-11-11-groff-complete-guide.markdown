---
layout: post
title:  "Тезисы"
subject: "Грофф - SQL. Полное руководство"
date:   2018-11-11 20:53:21 +0300
---

**SQL** появился как исследовательский продукт  фирмы IBM. Изначально назывался **SEQUEL** - **S**tructured **E**nglish **Que**ry **L**anguage но был переименован из-за конфликта прав.

Возможности:

* **Определение данных** позволяет определить структуру и оргинизацию хранимых данных
* **Выборка данных** позволяет извлекать данные
* **Обработка данных** позволяет добавлять, изменять и удалять данные
* **Управление доступом** ограничивает возможности выборки и изменения
* **Совместное использование** одновременное редактирование без потери данных
* **Контроль целостности** защита от несогласованного изменения или отказа системы

SQL - декларативный язык

### Ключевые свойства:

* **Независимость** от конкретной СУБД
* **Межплатформенная переносимость**
* **Наличие стандартов**
* **поддержка IBM**
* **поддержка Microsoft**
* **Реляционная модель**
* **Похож на естественный язык**
* **Интерактивные запросы**
* **Програмный доступ к БД**
* **Возможность различного представления данных**
* **Полноценность** в качестве языка работы с БД
* **Возможность динамического определения данных**
* **Поддержка архитектуры клиент/сервер**
* **Поддержка приложений уровня предприятия**
* **Расширяемость** и поддержка объектно-ориентированных технологий
* **Возможность доступа к данным в интернете**
* **JDBC** Интеграция м Java
* **Поддержка открытого кода**
* **Промышленная инфраструктура**

SQL обеспечивает независимость от конкретных СУБД

Microsoft поддерживает SQL через ODBC - Open Database Connectivity

### Проблемы переносимости

* **Типы данных**
* **Обратная совместимость**
* **Системные таблицы** - информация о структуре БД
* **Програмный интерфейс**
* **Семантические отличия** - разные результаты выполнения одного запроса
* **Репликация и зеркалирование** - реализрваны по разному
* **Коды ошибок**
* **Структура** - именование и установка подключений


### Архитектура

* **Централизованная** - Приложение и БД на одном сервере. Плохо масштабируется
* **Файловый сервер** - Одна база на сервере и СУБД на каждом клиенте
* **Клиент/Сервер** - БД и СУБД на сервере, клиент передаёт запросы


### Многоуровневая архитектура

* **Клиентский уровень** тонкий клиент - сайт, мобильное приложение
* **Прикладной уровень** Веб-сервер, сервер приложения
* **Серверный уровень** Сервер баз данных


### Модели данных

* **Иерархическая** - записи организованы в структуру предок-потомок
  * **Доступ к записям**
    * Найти по ID
    * Перейти к предку
    * Перейти к потомку
    * Перейти к соседу

  * **Характеристики**
    * Производительность
    * Простая структура
    * ассоциация предок-потомок через указатель

* **Сетевая** - одна запись может быть частью нескольких отношений предок-потомок (принадлежит множеству)
  * **Доступ к данным**
    * Найти по ID
    * перейти к первому потомку множества
    * перейти по горизонтали внутри множества
    * перейти вверх в другое множество

  * **Характеристики**
    * Гибкость структуры
    * Стандартизация (стандарт CODASYL)
    * Производительность

### Недостатки сетевой и иерархической модели

* Сложные статистические запросы
* Реализация каждого запроса отдельной программой
* Жёсткая структура

### **Реляционная модель** - табличная структура данных

  **Реляционной** называется БД в которой все данные организованны в виде таблиц и все операции выполняются над этими таблицами.

  Отношение предок-потомок реализовано через значения в таблицах

**Домен столбца** - множество значений, которые могут в нём содержаться

**Отношение** (relation) - мат. термин для таблицы, все строки которой различны между собой (в бд достигается за счёт уникального внешнего ключа)

### 12 Правил Кодда (Тед Кодд - создатель реляционной модели)

1. **Правило представления информации** - Вся информация представлена только на логическом уровне и только в виде значений таблиц
2. **Правило гарантированного доступа** - Доступ к каждому элементу данных возможен по комбинации имени таблицы, столбца и ID
3. **Систематическая трактовка значений NULL** - используются для обозначения неизвестной или неприменимой информации и ничему не равны
4. **Правило динамического католога, основанного на реляционной модели** - Описание БД на логическом уровне должно быть представлено в том же виде, что и данные, и могло быть изменено с помощью того жу языка
5. **Правило исчерпывающего подъязыка данных** - система может поддерживать несколько языков, хотя бы один, инструкции которого можно представить в виде строк символов в соответствии с точно определённым синтаксисом и который поддерживает:

    * Определение данных
    * Определение представлений
    * Обработку данных
    * Ограничение целостности данных
    * Авторизацию
    * Границы транзакций (Начало, фиксацию и откат)

6. **Правило обновления представлений** - Все представления, которые можно обновить, должны быть доступны для обновления
7. **Правило высокоуровневого обновления, добавления и удаления** - операции вставки, обновления и удаления должны быть применимы к отношению в целом
8. **Правило физической независимости данных** - Прикладные программы и утилиты должны оставаться независимыми при изменении способов хранения данных или методов доступа к ним
9. **Правило логической независимости данных** -  Прикладные программы и утилиты должны оставаться нетронутыми при внесении в базовые таблицы любых изменений
10. **Правило независимости контроля целостности** - Вся информация, необходимая для поддержания целостности, должна находиться в БД. Язык для работы с данными должен выполнять проверку входных данных и автоматически поддерживать целостность данных
11. **Независимость от расположения** - БД может быть распределённой, может находиться на нескольких компьютерах, и это не должно оказывать влияния на приложения. Перенос базы данных на другой компьютер не должен оказывать влияния на приложения.
12. **Согласование языковых уровней** - Если используется низкоуровневый язык доступа к данным, он не должен игнорировать правила безопасности и правила целостности, которые поддерживаются языком более высокого уровня.

### Выборка данных

В операторе `LIKE` управляющий символ может быть задан явно ```WHERE ... LIKE 'A$%BC' ESCAPE '$'```

`NATURAL JOIN` - соединение по всем одноимённым столбцам, `JOIN USING(A, B)` соединение по перечисленным одноимённым столбцам

Декартово произведение таблиц - таблица из всех возможных пар строк обеих таблиц

|T1|T2|
|---|---|
|a|1|
|b|2|

|T3|T4|
|---|---|
|c|3|
|d|4|

|T1|T2|T3|T4|
|---|---|---|---|
|a|1|c|3|
|a|1|d|4|
|b|2|c|3|
|b|2|d|4|

Соединением таблиц является их произведение, из которого исключены некоторые строки

Перекрёстное соединение (`CROSS JOIN`) - декартово произведение таблиц, равнозначно `SELECT * FROM A,B`

Соединение возможно по неравенству `JOIN ON A > B`

`UNION JOIN` (не поддерживается ни одной БД) - Полное внешнее соединение минус внутреннее

##### GIRLS

|name|surname|
|---|---|
|Lisa|Smitt|
|Ann|Wessonn|

###### BOYS

|name|surname|
|---|---|
|Joue|Doue|
|John|Daniels|

{% highlight sql %}
SELECT * FROM GIRLS UNION JOIN BOYS
{% endhighlight %} 

|name|surname|name|surname|
|---|---|---|---|
|Lisa|Smitt|NULL|NULL|
|Ann|Wessonn|NULL|NULL|
|NULL|NULL|Joue|Doue|
|NULL|NULL|John|Daniels|

По стандарту SQL1

Статистические функции не могут быть вложенными

Нельзя одновременно вывести столбец и статистическую функцию`SELECT name, SUM(age)`

NULL Игнорируется статистическими функциями (но есть исключения)

|A|B|
|---|---|
|1|4|
|2|NULL|
|3|5|

`SELECT COUNT(*)` => 3
`SELECT COUNT(A)` => 3 
`SELECT COUNT(B)` => 2

`SUM(A) + SUM(B)` => 15
`SUM(A + B)` => 13 (2 + NULL = NULL)

`DISTINCT` можно использовать внутри статистической функции чтобы применить её к неповторяющимся значениям

`DISTINCT` можно использовать только один раз за запрос

#### Общая сумма заказов для каждого клиента по каждому служащему

{% highlight sql %}  
  SELECT REP, CUST, SUM(AMOUNT)
  FROM ORDERS
  GROUP BY REP, CUST
{% endhighlight %}

|REP|CUST|SUM(AMOUNT)|
|---|---|---|
|101|2102|3978|
|101|2108|150|
|101|2113|22500|
|102|2106|4026|
|102|2114|15000|
|102|2120|3750|
|103|2111|2700|

#### Общая сумма заказов по каждому клиенту для каждого служащего с промежуточными итогами для каждого служащего

{% highlight sql %}
SELECT REP, CUST, SUM(AMOUNT)
FROM ORDERS
GROUP BY REP, CUST
WITH ROLLUP
{% endhighlight %}
|REP|CUST|SUM(AMOUNT)|
|---|---|---|
|101|2102|3978|
|101|2108|150|
|101|2113|22500|
|101|NULL|26628|
|102|2106|4026|
|102|2114|15000|
|102|2120|3750|
|102|NULL|22776|
|103|2111|2700|
|103|NULL|2700|

#### Сумма заказов для каждого служащего с промежуточными итогами для каждого служащего и клиента

{% highlight sql %}
SELECT REP, CUST, SUM(AMOUNT)
FROM ORDERS
GROUP BY REP, CUST
WITH CUBE
{% endhighlight %}

|REP|CUST|SUM(AMOUNT)|
|---|---|---|
|101|NULL|26628|
|101|2102|3978|
|101|2108|150|
|101|2113|22500|
|102|NULL|2276|
|102|2106|4026|
|102|2114|15000|
|102|2120|3750|
|103|NULL|2700|
|103|2111|2700|
|NULL|NULL|247691|
|NULL|2101|1458|
|NULL|2102|3978|
|NULL|2103|35582|
|NULL|2106|4026|
|NULL|2107|23132|

GROUP BY считает что ```NULL = NULL``` при условии равенства всех остальных значений в строке

В подзапросе внешним называется значение, которое берётся из внешнего запроса

При одинаковом имени столбца в запросе и подзапросе выражение будет относиться к ближайшему `FROM`

Стандарт SQL1

  - Ограничивается простыми запросами (`SELECT`, `GROUP BY`, `HAVING`, подзапросы)
  - Отсутствуют средства принятия решений (`IF/ELSE`, `CASE WHEN`)
  - Ограничения на подзапросы - нельзя сравнивать между собой, подзапрос всегда должен быть справа от оператора сравнения
  - Ограничены выражения со строками таблицы, нельзя выбрать строки подходящие под одно условие из списка (только через цепочку `AND/OR`)
  - нельзя включать подзапросы в `FROM` (`SELECT * FROM (SELECT ... )` )

Скалярные значения:
  * Значение отдельного столбца отдельной строки ("ячейки")
  * Литерал - `'abc'`, `123`
  * Значение ввода пользователя


### Способы вставки

* Однострочная инструкция `INSERT`
* Многострочная инструкция `INSERT`
* Пакетная загрузка

Условия целостности данных

* Обязательное наличие данных (`NOT NULL CONSTRAINT`)
* Условия на допустимые значения столбца
* Логическая целостность данных (Уникальность идентификатора)
* Ссылочная целостность - внешний ключ должен указывать на существующую строку
* Другие ограничения (специально заданные правила)
* Бизнес-правила
* Непротиворечивость

Правила удаления и обновления для отношения предок-потомок

* `RESTRICT` (`NO ACTION`) - запрещает удаление строки у которой есть потомки
* `CASCADE` - удаляет потомков вместе с родителем
* `SET NULL` - при удалении родителя дочерние ключи выставляются в NULL
* `SET DEFAULT` - при удалении родителя дочерние ключи выставляются в заданное значение

`SET NULL` выставляет в `NULL` только те столбцы, для которых это значение допустимо, столбцы с ограничением `NOT NULL` останутся без изменений

Составной ключ, одно из значений которого `NULL`, считается удовлетворяющим значению ссылочной целостности независимо от остальных значений. При создании таблицы можно установить режим обеспечения целостности данных: `MATCH FULL` - полное соответствие, в ключах не должно быть значений `NULL`; `MATCH PARTIAL` - допускаются значения `NULL` в ключе если остальная часть ключа присутствует в таблице предке.


Расширенные возможности ограничений

Ограничения столбцов - ограничивают значения, которые может содержать столбец.
Домены - форма ограничения столбца, например тип данных с условием (любые ```INTEGER > 10```)

Ограничения таблицы - ограничивают значения строк таблицы.

Утверждения - определяют взаимосвязь между значениями таблиц одной БД (`CREATE ASSERTION`)

Отложенная проверка ограничений - происходит после завершения транзакции.
`DEFFERABLE` - проверка может быть отложена
`NON DEFFERABLE` - проверка не может быть отложена

Ограничения могут быть:

`INITIALLY IMMEDIATE` - выполняется после каждой SQL инструкции (по умолчанию)
`INITIALLY DEFFERED` - проверка по окончанию транзакции

инструкция `SET CONSTRAINS` позволяет динамически изменять способ обработки ограничения - например в рамках текущей транзакции можно проверить выполнение ограничения в конце транзакции, хотя по умолчанию оно проверяется после каждой инструкции, но только если ограничение может быть отложено

Триггеры запускают набор инструкций при выполнении условия

Недостатки:

  * Сложность базы данных
  * Скрытые правила
  * Скрытое влияние на производительность

### ACID

* **A** - Atomic (Атомарность) транзакция применяется целиком или не применяется совсем
* **C** - Consistent (Целостность) транзакция переводит БД из одного согласованного состояния в другое согласованное состояние, все ограничения и проверки должны выполняться
* **I** - Isolated (Изоляция) каждая транзакция выполняется независимо от других транзакций
* **D** - Durable (Постоянство) По завершении транзакции данные должны быть сохранены и оставаться в согласованном состоянии даже в случае системного или аппаратного сбоя

инструкции в модели `ANSI/ISO`

`START TRANSACTION` - устанавливает свойства для новой транзакции и запускает её
`SET TRANSACTION` - устанавливает свойства очередной выполняемой транзакции не влияя на текущую (управляет следующей транзакцией)
`SET CONSTRAINS` - устанавливает режим ограничений транзакций (выполнять проверки сразу или откладывать)
`SAVEPOIN` - создаёт точку сохранения в пределах транзакции, которая будет промежуточной точкой отката транзакции
`RELEASE SAVEPOINT` - освобождает точку сохранения и все ресурсы
`COMMIT` - завершает транзакцию и сохраняет изменения в БД.
`ROLLBACK` - откатывает транзакцию к ближайшей точке сохранения или началу транзакции. При возврате к точке сохранения транзакция может быть продолжена

### Свойства транзакций

  * Уровень доступа - может ли транзакция содержать модифицирующие инструкции (`READ WRITE`) или только запросы на выборку данных (`READ ONLY` - по умолчанию)
  * Уровень изоляции - насколько транзация изолирована от других (`READ UNCOMMITED`, `READ COMMITED`, `REPEATABLE READ`, `SERIALIZABLE`) по умолчанию `SERIALIZABLE`
  * Размер диагностики - размер области для сообщений, генерируемых при выполненнии SQL (никем не реализована)

Для обеспечения атомарности в рамках транзакции в журнал транзакций сохраняются состояния строк до изменения и после

### Проблемы многопользовательских транзакций

#### Пропавшее обновление

Две транзакции параллельно считывают и изменяют результат

|T1| T2|
|---|---|
|COUNT = 100 | COUNT = 100|
|COUNT -= 50 | COUNT -= 60|
|COMMIT | -|
|COUNT => 50 | COMMIT|
|- | COUNT => 40|

От 100 в двух парралельных транзакциях вычитаем 50 и 60, получаем 40

#### Проблема промежуточных данных

|T1| T2|
|---|---|
|COUNT = 100 | COUNT = 100|
|COUNT -= 50 | COUNT => 50|
|- | COUNT += 10|
|- | COUNT => 60|
|ROLLBACK | -|
|COUNT => 100 | COUNT => 100|

Изменения применились к промежуточному значению, которое не было сохранено

#### Проблема несогласованности данных

|T1| T2|
|---|---|
|COUNT = 100 | COUNT = 100|
|- | COUNT -= 50|
|COUNT => 50 | -|

В рамках одной транзакции значение меняется, хотя никаких операций над ним не производилось

#### Проблема строк-призраков

|T1| T2|
|---|---|
|- | SELECT COUNT(ROW) => 10|
|INSERT ... | -|
|- | SELECT COUNT(ROW) => 11|

в рамках одной транзакции меняется количество существующих строк

Когда транзакции выполняются параллельно СУБД гарантирует что результат будет таким же как если бы они применялись в определённом порядке

Для обработки параллельных транзакций может применятся механизм блокировки чтобы предоставить транзакции монопольный доступ к данным

Уровни блокировки:

* База данных
* Таблица
* Страница (часть таблицы)
* Строка

Блокировка может быть:

* С обеспечением совместного доступа (`SHARED LOCK`) - другая транзакция может извлечь заблокированные данные
* Монопольная (`EXCLUSIVE LOCK`) Заблокированные данные не доступны другим транзакциям

Если данные уже заблокированы `SHARED LOCK` нельзя заблокировать их `EXCLUSIVE LOCK`

Для предотвращения взаимоблокировок СУБД периодически проверяет все блокировки и при нахождении взаимоблокировки отменяет одну произвольную транзакцию

Усовершенствованные методы блокировки

* Явная блокировка
* Уровни изоляции
* Параметры блокировки

|- | пропавшее обновление | промежуточные данные | несогласованные данные | строки-призраки|
|---|---|---|---|---|
|SERIALIZABLE | нет | нет | нет | нет|
|REPEATABLE READ | нет | нет | нет | возможно|
|READ COMMITED | нет | нет | возможно | возможно|
|READ UNCOMMITED | нет | возможно | возможно | возможно|


### Управление версиями

Когда в рамках транзакции изменяется строка создаётся её копия. В текущей транзакции используется изменённое значение, в других значение до изменения

Схема БД это ключевой высокоуровневый контейнер объектов в структуре БД. Он представляет собой именованную сущность в БД и включает в себя определение следующих объектов:

  * Таблицы вместе со связанными с ними структурами (столбцами, первичными и внешними ключами и т.п.)
  * Представления - виртуальные таблицы, создаваемые на основе реальных 
  * Домены - расширенные типы данных для определения столбцов в таблицах схемы 
  * Утверждения - проверки целостности БД, относящиеся ко всей базе
  * Привелегии - возможности пользователя для доступа к данным
  * наборы символов - представления нелатинских символов
  * порядки сортировки - правила сортировки текста для различных наборов символов
  * правила конвертирования текста - правила перевода текста между различными наборами символов и сравнения текстовых данных использующих различные наборы символов

### Представления

* Позволяют по разному показывать БД разным пользователям
* Позволяют дать пользователю доступ к части таблицы
* Упрощают структуру БД для уаждого пользователя

Материализованные представления - результат выборки сохранённый во временную таблицу

Преимущества представлений:

  * Безопасность - проще разграничить доступ пользователей
  * Простота запросов - к нескольким таблицам можно обращаться как к одной
  * Структурная простота - для каждого пользователя можно создать собственную структуру
  * Защита от изменений - интерфейс доступа к данным не зависит от структуры данных, имён таблиц и столбцов
  * Целостность данных - автоматическая проверка целостности

Недостатки:

  * Производительность - простой запрос к представлению это запрос к нескольким таблицам 
  * Управляемость - взаимосвязанные представления сложны в поддержке
  * Ограничения на обновления - сложные представления нельзя обновлять

Виды представлений:

* Горизонтальное - включает все столбцы таблицы но только часть строк (таблица отфильтрована по критерию)
* Вертикальное - все строки но только часть столбцов
* Сгруппированные - результат запроса с группировкой
* Соединённые - результат объединения таблиц
* Смешанное

Для обновления представления СУБД должна иметь возможность однозначно сопоставить строки и столбцы представления со строками и столбцами исходных таблиц

Можно создать дополнительные правила для проверки добавляемых в представление данных при его создании (WITH CHECK) - пользователь не сможет ввести данные, которые не подходят под условие выборки в представление

Материализованное представление - запрос на выборку, результат которого сохраняются в таблицу и синхронизируются с исходными таблицами

Привелегии пользователей:
* `SELECT`
* `INSERT`
* `DELETE`
* `UPDATE`

расширенные привелегии - могут относиться к отдельным столбцам а не всей таблице, добавляются 
* `REFERENCES` - позволяет делать столбец внешним ключом
* `USAGE` - управляет доступом к пользовательским наборам символов, правилам сортировки, доменам

Передача привелегий - ```GRANT ... WITH GRANT OPTION``` - право на передачу привелегий другому пользователю

`REVOKE` - отменяет привелегии, но может отменить только те, которые были даны выполняющим пользователем

Роль - именованный набор привелегий

Системный каталог - набор таблиц, хранящий служебную информацию о БД

Таблицы системного каталога хранят:

* Таблицы - имя, владелец ...
* Столбцы - имя, таблица ...
* Пользователи
* Представления
* Привелегии

**хранимые процедуры** - набор инструкций, реализующий какой-либо процесс
**функция** - программа, возвращающая одно значение для каждой строки. Может быть использована внутри
SQL инструкций практически везде где может быть использовано имя столбца или константа
**триггеры** - код, запускающий на выполнение процедуру при выполнении заданных условий

### Язык хранимых процедур (SPL - Stored Procedure Language) - набор элементов, реализующий:

* **Условное выполнение** - ```IF ... THEN ... ELSE```
* **Циклы** `WHILE` или `FOR` либо иная подобная структура
* **Блочная структура** Последовательность инструкций SQL может быть сгруппирована и использована в других управляющих конструкциях
* **Именованные переменные**
* **Именованные процедуры**

**Выходные параметры** - используются для возврата результатов процедуры, передаются в процедуру явно

{% highlight sql %}
  create procedure get_cust_info ( c_num in i nteger ,с_name out varchar ,r_name out varchar)
{% endhighlight %}

`c_num` - входной параметр, передаётся извне
`с_name`, `r_name` - выходные параметры, туда должны быть переданы проинициализированные переменные,
в которые будет записан результат выполнения

{% highlight sql %}
  declare the_name varchar(20) ,the_rep varchar(20);
  execute get_cust_info (2111 , the_name , the_rep) - ok, передано значение и переменные для возврата значений

  execute get_cust_info (2111) - ошибка, не переданы переменные для возврата значений

  execute get_cust_info (2111 , 12222 , the_rep) - ошибка, вместо переменной передано значение
{% endhighlight %}

### Преимущества хранимых процедур

* Производительность - хранимые процедуры компилируются (автоматически или по запросу) и за счёт этого
выполняются быстрее чем аналогичный набор инструкций
* Повторное использование -  можно вызывать из любых приложений
* Сокращение сетевого трафика - передаётся только название процедуры а не весь набор инструкций
* Безопасность - можно назначить отдельные привилегии, при этом привилегии на таблицы, с которыми
 работает процедура необязательны
* Инкапсуляция - можно создать публичный интерфейс для работы с данными
* Простота доступа - вызвать существующую процедуру проще чем писать аналогичные запросы
* Обеспечение бизнес-правил - если базой пользуются несколько приложений можно обеспечить выполнение 
  бизнес-правил на уровне бд

  Внешняя хранимая процедура - процедура, написанная на одном из традиционных языков программирования и скомпилированная вне СУБД



**триггер** - это особая хранимая процедура, которая вызывается в ответ на модификацию содержимого базы данных.

### Функции триггеров

* **Контроль изменений** Триггер может отслеживать и отменять определенные изменения, не разрешаемые в конкретной базе данных.

* **Каскадные операции** Триггер может обнаруживать определенные операции (например, удаление сведений о клиенте или служащем) и автоматически вносить соответствующие изменения в другие таблицы базы

* **Поддержка целостности** Триггер может померживать более сложные
связи между данными, чем те, которые могут быть выражены ограничениями на значения столбцов и условиями ссылочной целостности

* **Вызов хранимых процедур** 

* **Обнаружение системных событий** В СУБД с помержкой триггеровдля системных событий триггер может отслеживать, например, подключение к базе данных определенного пользователя.

Главным недостатком триггеров является их влияние на производительность операций с базой данных.

Хранилище данных - СУБД, оптимизированная для хранения больших объёмов данных и выполнения аналитических запросов на них

### Загрузка данных в хранилище

* **Извлечение данных** получение данных из разных источников
* **Очистка данных** фильтрация, проверка целостности
* **Перекрестная проверка данных** проверка согласованности данных из разных источников
* **Переформатирование** приведение данных к одному формату, разделение по таблицам
* **Вставка/обновление данных** обычно осуществляется без транзакций с помощью специальных пакетных механизмов
* **Создание/обновление индексов** 



### Производитеьность запросов

Для повышения производительности запросов, связанных с деловым анализом,
используется несколько технологий

* **Специализированные схемы индексации**  
* **Технологии параллельной обработки** 
* **Специализированные алгоритмы оптимизации** 
* **Разбиение таблиц и индексов** 
* **Тесная интеграция программного и аппаратного обеспечения**

### Характеристики объектно-ориентированной базы данных

* **Объекты** В ООБД любая сущность является объектом и обрабатывается как объект.
* **Классы**
* **Наследование**
* **Атрибуты**
* **Сообщения и методы** Объекты взаимодействуют друг с другом посредством сообщений. Когда объект получает сообщение, он отвечает на него, выполняя метод - подпрограмму, хранимую внуrри объекта, которая определяет способ обработки сообщения.
* **Инкапсуляция** Внуrренняя структура и данные объектов скрыты от внешнего мира за набором строго определенных интерфейсов.
* **Идентификаторы объектов** объект указывает на другой объект с помощью дескриптора, который он хранит в одном из своих атрибутов.


### основные объектные расширения, уже имеющиеся в современных БД

* **Большие объекты данных** могут хранить мультимедиа файлы
* **Структурированные/абстрактные типы данных** ROW - структура, например адресс, который состоит из города улицы и дома 

  ```SQL   
    ADDRESS ROW (STREET VARCHAR (35), CITY VARCНAR (15), STATE СНАR ( 2 ))
  ```

* **Пользовательские типы данных** именованные абстрактные типы, которые можно переиспользовать 
* **Таблицы в таблицах**
* **Последовательности, множества и массивы**
* **Хранимые процедуры**
* **Дескрипторы и идентификаторы объектов**


### Характеристики встраиваемых баз данных

* **Малое потребление памяти**
* **Отсутствие администрирования**
* **Поддержка нетрадиционного хранения** данные могут храниться в оперативной памяти,в энергонезависимой намяти, на USВ-диске или еще где-то
* **Ограниченная поддержка SQL**
* **Статическая схема базы данных**
* **Однопользовательская работа**
