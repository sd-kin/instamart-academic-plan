<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Тезисы | instamart acadenic plan</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Тезисы" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Mollinaro - SQL Cookbook notes" />
<meta property="og:description" content="Mollinaro - SQL Cookbook notes" />
<link rel="canonical" href="https://sd-kin.github.io/instamart-academic-plan/2018/11/11/mollinaro-coockbook.html" />
<meta property="og:url" content="https://sd-kin.github.io/instamart-academic-plan/2018/11/11/mollinaro-coockbook.html" />
<meta property="og:site_name" content="instamart acadenic plan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-11T20:55:21+03:00" />
<script type="application/ld+json">
{"url":"https://sd-kin.github.io/instamart-academic-plan/2018/11/11/mollinaro-coockbook.html","description":"Mollinaro - SQL Cookbook notes","headline":"Тезисы","dateModified":"2018-11-11T20:55:21+03:00","datePublished":"2018-11-11T20:55:21+03:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sd-kin.github.io/instamart-academic-plan/2018/11/11/mollinaro-coockbook.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/instamart-academic-plan/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://sd-kin.github.io/instamart-academic-plan/feed.xml" title="instamart acadenic plan" /></head>
<body>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Тезисы</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-11-11T20:55:21+03:00" itemprop="datePublished">Nov 11, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="mollinaro---sql-cookbook-notes">Mollinaro - SQL Cookbook notes</h2>

<h3 id="группировка">Группировка</h3>

<blockquote>
  <p>Способ организации подобных строк. Каждая строка результирующего множества представляет одну или более строк с одинаковыми значениями в одном или более заданных полях.</p>
</blockquote>

<p>В математике основным определением группы является тройка (G, •, e), где G – множество, • – бинарная операция над G, и e – член G. (бинарная операция — математическая операция, принимающая два аргумента и возвращающая один результат)</p>

<p>SQL группа определяется как пара (G, e), где G – результирующее множество самостоятельного или самодостаточного запроса, в котором используется оператор GROUP BY, e – член G, и выполняются
  следующие аксиомы:</p>

<ul>
  <li>Для каждого e в G e является уникальным и представляет один или более экземпляров e.</li>
  <li>Для каждого e в G агрегатная функция COUNT возвращает значение &gt; 0.</li>
</ul>

<p>(е можно считать строкой результирующего множества, поскольку фактически эти строки представляют собой группы)</p>

<p>Следствия:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Группы не могут быть пустыми
* Группы уникальны
</code></pre></div></div>

<h3 id="оконные-функции">Оконные функции</h3>

<p>выполняют агрегацию заданного набора (группы) строк, но вместо того чтобы возвращать по одному значению на группу могут возвращать несколько значений для каждой группы. Группа строк, подвергающаяся агрегации называется “окно”</p>

<p>оконные функции выполняются как последний шаг в обработке SQL перед оператором <code class="highlighter-rouge">ORDER BY</code></p>

<p>Для определения сегмента или группы строк, подвергающихся агрегации, используется оператор <code class="highlighter-rouge">PARTITION BY</code>. Оператор <code class="highlighter-rouge">PARTITION BY</code> можно рассматривать как «скользящий<code class="highlighter-rouge"> GROUP BY</code>», потому что в отличие от обычного <code class="highlighter-rouge">GROUP BY</code> группы, создаваемые <code class="highlighter-rouge">PARTITION BY</code>, в результирующем множестве не являются уникальными. <code class="highlighter-rouge">PARTITION BY</code> может использоваться для вычисления агрегата заданной группы строк (отсчет начинается заново для каждой новой группы), и тогда будут представлены все экземпляры этого значения в таблице (все члены каждой группы), а не одна группа.</p>

<pre><code class="language-SQL">    select ename, deptno, count(*) over(partition by deptno) as cnt
    from emp
    order by 2
</code></pre>

<table>
  <thead>
    <tr>
      <th>ENAME</th>
      <th>DEPTNO</th>
      <th>CNT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CLARK</td>
      <td>10</td>
      <td>3</td>
    </tr>
    <tr>
      <td>KING</td>
      <td>10</td>
      <td>3</td>
    </tr>
    <tr>
      <td>SMITH</td>
      <td>20</td>
      <td>5</td>
    </tr>
    <tr>
      <td>FORD</td>
      <td>20</td>
      <td>5</td>
    </tr>
    <tr>
      <td>SCOTT</td>
      <td>20</td>
      <td>5</td>
    </tr>
    <tr>
      <td>ALLEN</td>
      <td>30</td>
      <td>6</td>
    </tr>
    <tr>
      <td>BLAKE</td>
      <td>30</td>
      <td>6</td>
    </tr>
    <tr>
      <td>JAMES</td>
      <td>30</td>
      <td>6</td>
    </tr>
    <tr>
      <td>TURNER</td>
      <td>30</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

<p>аналогичный результат можноа получить без оконных функций с помощью</p>

<pre><code class="language-SQL">    select e.ename,
           e.deptno,
           (select count(*) from emp d where e.deptno=d.deptno) as cnt
    from emp e
    order by 2
</code></pre>

<p>Оператор <code class="highlighter-rouge">PARTITION BY</code> выполняет вычисления независимо от других оконных функций, осуществляя сегментирование по другим столбцам в том же выражении <code class="highlighter-rouge">SELECT</code>.</p>

<pre><code class="language-SQL">    select ename,
           deptno,
           count(*) over(partition by deptno) as dept_cnt,
           job,
           count(*) over(partition by job) as job_cnt
    from emp
    order by 2
</code></pre>

<table>
  <thead>
    <tr>
      <th>ENAME</th>
      <th>DEPTNO</th>
      <th>DEPT_CNT</th>
      <th>JOB</th>
      <th>JOB_CNT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MILLER</td>
      <td>10</td>
      <td>3</td>
      <td>CLERK</td>
      <td>4</td>
    </tr>
    <tr>
      <td>CLARK</td>
      <td>10</td>
      <td>3</td>
      <td>MANAGER</td>
      <td>3</td>
    </tr>
    <tr>
      <td>KING</td>
      <td>10</td>
      <td>3</td>
      <td>PRESIDENT</td>
      <td>1</td>
    </tr>
    <tr>
      <td>SCOTT</td>
      <td>20</td>
      <td>5</td>
      <td>ANALYST</td>
      <td>2</td>
    </tr>
    <tr>
      <td>FORD</td>
      <td>20</td>
      <td>5</td>
      <td>ANALYST</td>
      <td>2</td>
    </tr>
    <tr>
      <td>SMITH</td>
      <td>20</td>
      <td>5</td>
      <td>CLERK</td>
      <td>4</td>
    </tr>
    <tr>
      <td>JONES</td>
      <td>20</td>
      <td>5</td>
      <td>MANAGER</td>
      <td>3</td>
    </tr>
    <tr>
      <td>ADAMS</td>
      <td>20</td>
      <td>5</td>
      <td>CLERK</td>
      <td>4</td>
    </tr>
    <tr>
      <td>JAMES</td>
      <td>30</td>
      <td>6</td>
      <td>CLERK</td>
      <td>4</td>
    </tr>
    <tr>
      <td>MARTIN</td>
      <td>30</td>
      <td>6</td>
      <td>SALESMAN</td>
      <td>4</td>
    </tr>
    <tr>
      <td>TURNER</td>
      <td>30</td>
      <td>6</td>
      <td>SALESMAN</td>
      <td>4</td>
    </tr>
    <tr>
      <td>WARD</td>
      <td>30</td>
      <td>6</td>
      <td>SALESMAN</td>
      <td>4</td>
    </tr>
    <tr>
      <td>ALLEN</td>
      <td>30</td>
      <td>6</td>
      <td>SALESMAN</td>
      <td>4</td>
    </tr>
    <tr>
      <td>BLAKE</td>
      <td>30</td>
      <td>6</td>
      <td>MANAGER</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Оператор <code class="highlighter-rouge">ORDER BY</code>, используемый в операторе <code class="highlighter-rouge">OVER</code> оконной функции, определяет две вещи:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Как упорядочены строки в сегменте.
2. Какие строки участвуют в вычислениях.
</code></pre></div></div>

<pre><code class="language-SQL">    select deptno,
           ename,
           hiredate,
           sal,
           sum(sal)over(order by hiredate) as running_total
    from emp
    where deptno=10
</code></pre>

<table>
  <thead>
    <tr>
      <th>DEPTNO</th>
      <th>ENAME</th>
      <th>HIREDATE</th>
      <th>SAL</th>
      <th>RUNNING_TOTAL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10</td>
      <td>CLARK</td>
      <td>09JUN1981</td>
      <td>2450</td>
      <td>2450</td>
    </tr>
    <tr>
      <td>10</td>
      <td>KING</td>
      <td>17NOV1981</td>
      <td>5000</td>
      <td>7450</td>
    </tr>
    <tr>
      <td>10</td>
      <td>MILLER</td>
      <td>23JAN1982</td>
      <td>1300</td>
      <td>8750</td>
    </tr>
  </tbody>
</table>

<p>считается сумма от начала окна до текущей строки</p>

<p>Следующий запрос аналогичен предыдущему, но в нем поведение по умолчанию, являющееся результатом применения <code class="highlighter-rouge">ORDER BY HIRE DATE</code>, явно задается оператором <code class="highlighter-rouge">RANGE BETWEEN</code></p>

<pre><code class="language-SQL">    select deptno,
           ename,
           hiredate,
           sal,
           sum(sal)over(order by hiredate range between unbounded preceding and current row) as running_total
    from emp
    where deptno=10
</code></pre>

<p>Оператор <code class="highlighter-rouge">RANGE BETWEEN</code> ANSI называет оператором кадрирования</p>

<p><code class="highlighter-rouge">ORDER BY</code> определяет порядок вычисления и также подразумевает кадрирование по умолчанию</p>

<pre><code class="language-SQL">    select deptno,
           ename,
           sal,
           sum(sal)over(order by hiredate range between unbounded preceding and current row) as run_total1,
           sum(sal)over(order by hiredate rows between 1 preceding and current row) as run_total2,
           sum(sal)over(order by hiredate range between current row and unbounded following) as run_total3,
           sum(sal)over(order by hiredate rows between current row and 1 following) as run_total4
    from emp
    where deptno=10
</code></pre>

<table>
  <thead>
    <tr>
      <th>DEPTNO</th>
      <th>ENAME</th>
      <th>SAL</th>
      <th>RUN_TOTAL1</th>
      <th>RUN_TOTAL2</th>
      <th>RUN_TOTAL3</th>
      <th>RUN_TOTAL4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10</td>
      <td>CLARK</td>
      <td>2450</td>
      <td>2450</td>
      <td>2450</td>
      <td>8750</td>
      <td>7450</td>
    </tr>
    <tr>
      <td>10</td>
      <td>KING</td>
      <td>5000</td>
      <td>7450</td>
      <td>7450</td>
      <td>6300</td>
      <td>6300</td>
    </tr>
    <tr>
      <td>10</td>
      <td>MILLER</td>
      <td>1300</td>
      <td>8750</td>
      <td>6300</td>
      <td>1300</td>
      <td>1300</td>
    </tr>
  </tbody>
</table>

<p><strong>RUN_TOTAL2</strong> - Вместо ключевого слова <code class="highlighter-rouge">RANGE</code> в данном операторе кадрирования используется <code class="highlighter-rouge">ROWS</code>; это означает, что кадр, или окно, будет создано из некоторого количества строк. <code class="highlighter-rouge">1 PRECEDING</code> говорит о том, что кадр будет начинаться со строки, стоящей непосредственно перед текущей строкой. Диапазон распространяется до <code class="highlighter-rouge">CURRENT ROW</code>. Таким образом, <strong>RUN_TOTAL2</strong> – это сумма заработных плат текущего и предыдущего, на основании <code class="highlighter-rouge">HIREDATE</code>, сотрудников.</p>

<p><strong>RUN_TOTAL3</strong> - Оконная функция для вычисления <strong>RUN_TOTAL3</strong> выполняет обратное тому, что делалось для <strong>RUN_TOTAL1</strong>. Суммирование начинается с текущей строки и включает не все предыдущие строки, а все последующие строки.</p>

<p><strong>RUN_TOTAL4</strong> - Инверсия <strong>RUN_TOTAL2</strong>. Суммирование начинается с текущей строки и включает не одну предыдущую, а одну следующую строку.</p>

<h3 id="1-извлечение-записей-стр-33">1 Извлечение записей (стр. 33)</h3>

<h4 id="извлечение-всех-строк-и-столбцов-из-таблицы">Извлечение всех строк и столбцов из таблицы</h4>

<pre><code class="language-SQL">  select * from emp
</code></pre>

<h4 id="извлечение-подмножества-строк-из-таблицы-стр-34">Извлечение подмножества строк из таблицы (стр. 34)</h4>

<pre><code class="language-SQL">  select * from emp where deptno = 10
</code></pre>

<h4 id="выбор-строк-по-нескольким-условиям-стр-34">Выбор строк по нескольким условиям (стр. 34)</h4>

<pre><code class="language-SQL">  select * from emp where deptno = 10 or comm is not null or sal &lt;= 2000 and deptno = 20
</code></pre>

<h4 id="извлечение-подмножества-столбцов-из-таблицы-стр-35">Извлечение подмножества столбцов из таблицы (стр. 35)</h4>

<pre><code class="language-SQL">  select ename, deptno, sal from emp
</code></pre>

<h4 id="как-задать-столбцам-значимые-имена-стр-36">Как задать столбцам значимые имена (стр. 36)</h4>

<pre><code class="language-SQL">  select sal as salary, comm as commission from emp 
</code></pre>

<table>
  <thead>
    <tr>
      <th>SALARY</th>
      <th>COMMISSION</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>800</td>
      <td> </td>
    </tr>
    <tr>
      <td>1600</td>
      <td>300</td>
    </tr>
    <tr>
      <td>1250</td>
      <td>500</td>
    </tr>
    <tr>
      <td>2975</td>
      <td> </td>
    </tr>
    <tr>
      <td>1250</td>
      <td>1300</td>
    </tr>
    <tr>
      <td>2850</td>
      <td> </td>
    </tr>
    <tr>
      <td>2450</td>
      <td> </td>
    </tr>
    <tr>
      <td>3000</td>
      <td> </td>
    </tr>
    <tr>
      <td>5000</td>
      <td> </td>
    </tr>
    <tr>
      <td>1500</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1100</td>
      <td> </td>
    </tr>
    <tr>
      <td>950</td>
      <td> </td>
    </tr>
    <tr>
      <td>3000</td>
      <td> </td>
    </tr>
    <tr>
      <td>1300</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="обращение-к-столбцу-в-предикате-where-по-псевдониму-стр-37">Обращение к столбцу в предикате WHERE по псевдониму (стр. 37)</h4>

<p>Чтобы обратиться к столбцу по псевдониму, необходимо использовать вложенный запрос:</p>

<pre><code class="language-SQL">  select *
  from (
    select sal as salary, comm as commission
    from emp
  ) x
  where salary &lt; 5000
</code></pre>

<p>Предикат <code class="highlighter-rouge">WHERE</code> обрабатывается раньше оператора <code class="highlighter-rouge">SELECT</code>, оператор <code class="highlighter-rouge">FROM</code> выполняется до предиката <code class="highlighter-rouge">WHERE</code>. Размещение исходного запроса в операторе <code class="highlighter-rouge">FROM</code> обеспечивает формирование его результатов до обработки самого внешнего <code class="highlighter-rouge">WHERE</code></p>

<h4 id="конкатенация-значений-столбцов-стр-38">Конкатенация значений столбцов (стр. 38)</h4>

<pre><code class="language-SQL">  select concat(ename, ' WORKS AS A ',job) as msg
  from
  where deptno=10
</code></pre>

<h4 id="использование-условной-логики-в-выражении-select-стр-39">Использование условной логики в выражении SELECT (стр. 39)</h4>

<pre><code class="language-SQL">  select ename,
         sal,
         case 
           when sal &lt;= 2000 then 'UNDERPAID'
           when sal &gt;= 4000 then 'OVERPAID'
           else 'OK'
         end as status
  from emp
</code></pre>

<h4 id="ограничение-числа-возвращаемых-строк-стр-40">Ограничение числа возвращаемых строк (стр. 40)</h4>

<pre><code class="language-SQL">  select * from emp limit 5
</code></pre>

<h4 id="возвращение-n-случайных-записей-таблицы-стр-42">Возвращение n случайных записей таблицы (стр. 42)</h4>

<pre><code class="language-SQL">  select ename,job
  from emp
  order by rand()
  limit 5
</code></pre>

<h4 id="поиск-значений-null-стр-44">Поиск значений NULL (стр. 44)</h4>

<pre><code class="language-SQL">  select * from emp where comm is null
</code></pre>

<h4 id="преобразование-значений-null-в-неnull-значения-стр-44">Преобразование значений NULL в неNULL значения (стр. 44)</h4>

<pre><code class="language-SQL">  select coalesce(comm,0) from emp
</code></pre>

<p>Функция COALESCE принимает в качестве аргументов одно или более значений. Функция возвращает первое не NULL значение из списка.</p>

<h4 id="поиск-по-шаблону-стр-45">Поиск по шаблону (стр. 45)</h4>

<pre><code class="language-SQL">  select ename, job
  from emp
  where deptno in (10,20)
  and (ename like '%I%' or job like '%ER')
</code></pre>

<h3 id="2-сортировка-результатов-запроса-стр-47">2 Сортировка результатов запроса (стр. 47)</h3>

<h4 id="возвращение-результатов-запроса-в-заданном-порядке">Возвращение результатов запроса в заданном порядке</h4>

<pre><code class="language-SQL">  select ename,job,sal
  from emp
  where deptno = 10
  order by sal asc
</code></pre>

<h4 id="сортировка-по-нескольким-полям-стр-48">Сортировка по нескольким полям (стр. 48)</h4>

<pre><code class="language-SQL">  select empno,deptno,sal,ename,job
  from emp
  order by deptno, sal desc
</code></pre>

<h4 id="сортировка-по-подстрокам-стр-49">Сортировка по подстрокам (стр. 49)</h4>

<pre><code class="language-SQL">  select ename,job
  from emp
   order by substr(job,length(job)-2,2)
</code></pre>

<h4 id="сортировка-смешанных-буквенноцифровых-данных-стр-50">Сортировка смешанных буквенноцифровых данных (стр. 50)</h4>

<p>Требуется сортировать смешанные буквенно-цифровые данные по числовой или символьной части.</p>

<table>
  <thead>
    <tr>
      <th>DATA</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SMITH 20</td>
    </tr>
    <tr>
      <td>ALLEN 30</td>
    </tr>
    <tr>
      <td>WARD 30</td>
    </tr>
    <tr>
      <td>JONES 20</td>
    </tr>
    <tr>
      <td>MARTIN 30</td>
    </tr>
    <tr>
      <td>BLAKE 30</td>
    </tr>
    <tr>
      <td>CLARK 10</td>
    </tr>
    <tr>
      <td>SCOTT 20</td>
    </tr>
    <tr>
      <td>KING 10</td>
    </tr>
    <tr>
      <td>TURNER 30</td>
    </tr>
    <tr>
      <td>ADAMS 20</td>
    </tr>
    <tr>
      <td>JAMES 30</td>
    </tr>
    <tr>
      <td>FORD 20</td>
    </tr>
    <tr>
      <td>MILLER 10</td>
    </tr>
  </tbody>
</table>

<p>Oracle и PostgreSQL</p>

<pre><code class="language-SQL">  /* СОРТИРУЕМ ПО DEPTNO */
  select data
  from V
  order by replace(data, /* убираем строковую часть, остаётся только номер */
    replace( /* убираем все #, остаётся строковая часть */
      translate( /* замена цифр на # */
        data,'0123456789','##########'),
        '#',
        ''
      ),
    '')
  
  /* СОРТИРУЕМ ПО ENAME */
  select data
  from emp
  order by replace(translate(data,'0123456789','##########'),'#','')
</code></pre>

<p>MySQL и SQL Server</p>

<p>В настоящее время данные платформы не поддерживают функцию
TRANSLATE, таким образом, решения для этой задачи нет.</p>

<h4 id="обработка-значений-null-при-сортировке-стр-53">Обработка значений NULL при сортировке (стр. 53)</h4>

<p>В зависимости от того, как должны быть представлены данные (и как конкретная СУБД сортирует значения <code class="highlighter-rouge">NULL</code>), столбцы, допускающие неопределенные значения, можно сортировать по возврастанию или по убыванию:</p>

<pre><code class="language-SQL">  select ename,sal,comm
  from emp
  order by 3

  select ename,sal,comm
  from emp
  order by 3 desc
</code></pre>

<p>Если необходимо сортировать неопределенные значения иначе, чем определенные, например расположить определенные значения по убыванию или возрастанию, а все значения <code class="highlighter-rouge">NULL</code> вывести поcле</p>

<pre><code class="language-SQL">  select ename,sal,comm
  from (
    select ename,sal,comm,
    case when comm is null then 0 else 1 end as is null
    from emp
  ) x
  order by is_null desc, comm
</code></pre>

<h4 id="сортировка-по-зависящему-от-данных-ключу-стр-60">Сортировка по зависящему от данных ключу (стр. 60)</h4>

<p>если значение JOB – «SALESMAN», сортировка должна осуществляться по столбцу COMM; в противном случае сортируем по SAL.</p>

<pre><code class="language-SQL">  select ename,sal,job,comm
  from emp
  order by case when job = 'SALESMAN' then comm else sal end
</code></pre>

<h3 id="3-работа-с-несколькими-таблицами-стр-62">3 Работа с несколькими таблицами (стр. 62)</h3>

<h4 id="размещение-одного-набора-строк-под-другим-стр-62">Размещение одного набора строк под другим (стр. 62)</h4>

<pre><code class="language-SQL">  select ename as ename_and_dname, deptno
  from emp
  where deptno = 10
  
  union all
  
  select '-----------', null from t1
  
  union all
  select dname, deptno
  from dept
</code></pre>

<table>
  <thead>
    <tr>
      <th>ENAME_AND_DNAME</th>
      <th>DEPTNO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CLARK</td>
      <td>10</td>
    </tr>
    <tr>
      <td>KING</td>
      <td>10</td>
    </tr>
    <tr>
      <td>MILLER</td>
      <td>10</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>ACCOUNTING</td>
      <td>10</td>
    </tr>
    <tr>
      <td>RESEARCH</td>
      <td>20</td>
    </tr>
    <tr>
      <td>SALES</td>
      <td>30</td>
    </tr>
    <tr>
      <td>OPERATIONS</td>
      <td>40</td>
    </tr>
  </tbody>
</table>

<h4 id="объединение-взаимосвязанных-строк-стр-64">Объединение взаимосвязанных строк (стр. 64)</h4>

<pre><code class="language-SQL">  select e.ename, d.loc
  from emp e, dept d
  where e.deptno = d.deptno
  and e.deptno = 10
</code></pre>

<pre><code class="language-SQL">  select e.ename, d.loc
  from emp e
    inner join dept d on (e.deptno = d.deptno)
  where e.deptno = 10
</code></pre>

<blockquote>
  <p>Объединение – это операция, в результате которой строки двух таблиц соединяются в одну.</p>
</blockquote>

<blockquote>
  <p>Эквиобъединение – это объединение, в котором условием объединения является равенство</p>
</blockquote>

<h4 id="поиск-одинаковых-строк-в-двух-таблицах-стр-66">Поиск одинаковых строк в двух таблицах (стр. 66)</h4>

<pre><code class="language-SQL">  select * from V
</code></pre>

<table>
  <thead>
    <tr>
      <th>ENAME</th>
      <th>JOB</th>
      <th>SAL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SMITH</td>
      <td>CLERK</td>
      <td>800</td>
    </tr>
    <tr>
      <td>ADAMS</td>
      <td>CLERK</td>
      <td>1100</td>
    </tr>
    <tr>
      <td>JAMES</td>
      <td>CLERK</td>
      <td>950</td>
    </tr>
    <tr>
      <td>MILLER</td>
      <td>CLERK</td>
      <td>1300</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-SQL">  select e.empno,e.ename,e.job,e.sal,e.deptno
  from emp e, V
  where e.ename = v.ename
    and e.job = v.job
    and e.sal = v.sal
</code></pre>

<pre><code class="language-SQL">  select e.empno,e.ename,e.job,e.sal,e.deptno
  from emp e join V
    on ( e.ename = v.ename
      and e.job = v.job
      and e.sal = v.sal )
</code></pre>

<h5 id="db2-oracle-и-postgresql">DB2, Oracle и PostgreSQL</h5>

<p>Если нет необходимости возвращать столбцы представления V, можно использовать операцию над множествами INTERSECT в сочетании с предикатом IN:</p>

<pre><code class="language-SQL">  select empno,ename,job,sal,deptno
  from emp
  where (ename,job,sal) in (
    select ename,job,sal from emp
    intersect
    select ename,job,sal from V
  )
</code></pre>

<h4 id="извлечение-из-одной-таблицы-значений-которых-нет-в-другой-таблице-стр-68">Извлечение из одной таблицы значений, которых нет в другой таблице (стр. 68)</h4>

<h5 id="db2-and-postgresql">DB2 and PostgreSQL</h5>

<pre><code class="language-SQL">  select deptno from dept
  except
  select deptno from emp
</code></pre>

<h5 id="oracle">Oracle</h5>

<pre><code class="language-SQL">  select deptno from dept
  minus
  select deptno from emp
</code></pre>

<h5 id="mysql-и-sql-server">MySQL и SQL Server</h5>

<pre><code class="language-SQL">  select deptno
  from dept
  where deptno not in (select deptno from emp)
</code></pre>
<p>При использовании оператора <code class="highlighter-rouge">NOT IN</code> не забывайте о значениях <code class="highlighter-rouge">NULL</code>. По сути, <code class="highlighter-rouge">IN</code> и <code class="highlighter-rouge">NOT IN</code> – операции логического ИЛИ. Формируемый ими результат зависит от того, как интерпретируются значения <code class="highlighter-rouge">NULL</code> при вычислении логического ИЛИ. В SQL выражению «<code class="highlighter-rouge">TRUE or NULL</code>» соответствует <code class="highlighter-rouge">TRUE</code>, а «<code class="highlighter-rouge">FALSE or NULL</code>» – <code class="highlighter-rouge">NULL</code>! Полученный результат <code class="highlighter-rouge">NUL</code>L обеспечит <code class="highlighter-rouge">NULL</code> при последующих вычислениях. Во избежание проблем с <code class="highlighter-rouge">NOT IN</code> и значениями <code class="highlighter-rouge">NULL</code> применяются связанные подзапросы в сочетании с предикатом <code class="highlighter-rouge">NOT EXISTS</code>.</p>

<pre><code class="language-SQL">  select d.deptno
  from dept d
  where not exists ( 
    select null
    from emp e
    where d.deptno = e.deptno )
</code></pre>

<h4 id="извлечение-из-таблицы-строк-для-которых-нет-соответствия-в-другой-таблице-стр-72">Извлечение из таблицы строк, для которых нет соответствия в другой таблице (стр. 72)</h4>

<pre><code class="language-SQL">select d.*
from dept d
  left outer join emp e on (d.deptno = e.deptno)
where e.deptno is null
</code></pre>

<h4 id="независимое-добавление-объединений-в-запрос-стр-74">Независимое добавление объединений в запрос (стр. 74)</h4>

<p>Для получения дополнительной информации без утраты данных, возвращенных в результате исходного запроса, можно использовать внешнее объединение.</p>

<pre><code class="language-SQL">  select e.ename, d.loc, eb.received
  from emp e 
    join dept d on (e.deptno=d.deptno)
    left join emp_bonus eb on (e.empno=eb.empno)
  order by 2
</code></pre>

<h4 id="выявление-одинаковых-данных-в-двух-таблицах-стр-76">Выявление одинаковых данных в двух таблицах (стр. 76)</h4>

<p>Функции, осуществляющие вычитание множеств (<code class="highlighter-rouge">MINUS</code> или <code class="highlighter-rouge">EXCEPT</code>, в зависимости от СУБД), существенно упрощают задачу по сравнению таблиц. Если ваша СУБД не поддерживает таких функций, можно использовать связанный подзапрос.</p>

<pre><code class="language-SQL">  select * from V
</code></pre>

<table>
  <thead>
    <tr>
      <th>EMPNO</th>
      <th>ENAME</th>
      <th>JOB</th>
      <th>MGR</th>
      <th>HIREDATE</th>
      <th>SAL</th>
      <th>COMM</th>
      <th>DEPTNO</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>7369</td>
      <td>SMITH</td>
      <td>CLERK</td>
      <td>7902</td>
      <td>17DEC1980</td>
      <td>800</td>
      <td>20</td>
      <td> </td>
    </tr>
    <tr>
      <td>7499</td>
      <td>ALLEN</td>
      <td>SALESMAN</td>
      <td>7698</td>
      <td>20FEB1981</td>
      <td>1600</td>
      <td>300</td>
      <td>30</td>
    </tr>
    <tr>
      <td>7521</td>
      <td>WARD</td>
      <td>SALESMAN</td>
      <td>7698</td>
      <td>22FEB1981</td>
      <td>1250</td>
      <td>500</td>
      <td>30</td>
    </tr>
    <tr>
      <td>7566</td>
      <td>JONES</td>
      <td>MANAGER</td>
      <td>7839</td>
      <td>02APR1981</td>
      <td>2975</td>
      <td>20</td>
      <td> </td>
    </tr>
    <tr>
      <td>7654</td>
      <td>MARTIN</td>
      <td>SALESMAN</td>
      <td>7698</td>
      <td>28SEP1981</td>
      <td>1250</td>
      <td>1400</td>
      <td>30</td>
    </tr>
    <tr>
      <td>7698</td>
      <td>BLAKE</td>
      <td>MANAGER</td>
      <td>7839</td>
      <td>01MAY1981</td>
      <td>2850</td>
      <td>30</td>
      <td> </td>
    </tr>
    <tr>
      <td>7788</td>
      <td>SCOTT</td>
      <td>ANALYST</td>
      <td>7566</td>
      <td>09DEC1982</td>
      <td>3000</td>
      <td>20</td>
      <td> </td>
    </tr>
    <tr>
      <td>7844</td>
      <td>TURNER</td>
      <td>SALESMAN</td>
      <td>7698</td>
      <td>08SEP1981</td>
      <td>1500</td>
      <td>0</td>
      <td>30</td>
    </tr>
    <tr>
      <td>7876</td>
      <td>ADAMS</td>
      <td>CLERK</td>
      <td>7788</td>
      <td>12JAN1983</td>
      <td>1100</td>
      <td>20</td>
      <td> </td>
    </tr>
    <tr>
      <td>7900</td>
      <td>JAMES</td>
      <td>CLERK</td>
      <td>7698</td>
      <td>03DEC1981</td>
      <td>950</td>
      <td>30</td>
      <td> </td>
    </tr>
    <tr>
      <td>7902</td>
      <td>FORD</td>
      <td>ANALYST</td>
      <td>7566</td>
      <td>03DEC1981</td>
      <td>3000</td>
      <td>20</td>
      <td> </td>
    </tr>
    <tr>
      <td>7521</td>
      <td>WARD</td>
      <td>SALESMAN</td>
      <td>7698</td>
      <td>22FEB1981</td>
      <td>1250</td>
      <td>500</td>
      <td>30</td>
    </tr>
  </tbody>
</table>

<p>Требуется выяснить, имеются ли в этом представлении такие же данные, как и в таблице EMP.</p>

<h5 id="db2-и-postgresql">DB2 и PostgreSQL</h5>

<pre><code class="language-SQL">  (
    select empno, ename , job, mgr, hiredate, sal, comm, deptno, count(*) as cnt
    from V
    group by empno, ename, job, mgr, hiredate, sal, comm, deptno
    
    except
    
    select empno, ename, job, mgr, hiredate, sal, comm, deptno, count(*) as cnt
    from emp
    group by empno, ename, job, mgr, hiredate, sal, comm, deptno
  )
     
  union all
     
  (
    select empno, ename, job, mgr, hiredate, sal, comm, deptno, count(*) as cnt
    from emp
    group by empno, ename, job, mgr, hiredate, sal, comm, deptno
    
    except
    
    select empno, ename, job, mgr, hiredate, sal, comm, deptno, count(*) as cnt
    from v
    group by empno, ename, job, mgr, hiredate, sal, comm, deptno
  )
</code></pre>

<h5 id="mysql-и-sql-server-1">MySQL и SQL Server</h5>

<pre><code class="language-SQL">  select *
  from (
    select e.empno, e.ename, e.job, e.mgr, e.hiredate, e.sal, e.comm, e.deptno, count(*) as cnt
    from emp e
    group by empno, ename, job, mgr, hiredate, sal, comm, deptno
  ) e
  where not exists (
    select null
    from (
      select v.empno, v.ename, v.job, v.mgr, v.hiredate, v.sal, v.comm, v.deptno, count(*) as cnt
      from v
      group by empno, ename, job, mgr, hiredate, sal, comm, deptno
    ) v
    where v.empno = e.empno
      and v.ename = e.ename
      and v.job = e.job
      and v.mgr = e.mgr
      and v.hiredate = e.hiredate
      and v.sal = e.sal
      and v.deptno = e.deptno
      and v.cnt = e.cnt
      and coalesce(v.comm,0) = coalesce(e.comm,0)
  )

  union all

  select *
  from (
    select v.empno, v.ename, v.job, v.mgr, v.hiredate, v.sal, v.comm, v.deptno, count(*) as cnt
    from v
    group by empno, ename, job, mgr, hiredate, sal, comm, deptno
  ) v
  where not exists (
    select null
    from (
      select e.empno, e.ename, e.job, e.mgr, e.hiredate, e.sal, e.comm, e.deptno, count(*) as cnt
      from emp e
      group by empno, ename, job, mgr, hiredate, sal, comm, deptno
    ) e
    where v.empno = e.empno
      and v.ename = e.ename
      and v.job = e.job
      and v.mgr = e.mgr
      and v.hiredate = e.hiredate
      and v.sal = e.sal
      and v.deptno = e.deptno
      and v.cnt = e.cnt
      and coalesce(v.comm,0) = coalesce(e.comm,0)
  )
</code></pre>

<h4 id="идентификация-и-устранение-некорректного-использования-декартова-произведения-стр-83">Идентификация и устранение некорректного использования декартова произведения (стр. 83)</h4>

<p>Требуется возвратить имя каждого служащего 10!го отдела и местонахождение отдела.</p>

<pre><code class="language-SQL">  select e.ename, d.loc
  from emp e, dept d
  where e.deptno = 10
    and d.deptno = e.deptno
</code></pre>

<p>Обычно, чтобы не происходило прямого (декартова) произведения, применяется правило n–1, где n представляет количество таблиц в FROM, а n–1 – минимальное число объединений, необходимое во избежание прямого произведения.</p>

<h4 id="осуществление-объединений-при-использовании-агрегатных-функций-стр-85">Осуществление объединений при использовании агрегатных функций (стр. 85)</h4>

<p>Необходимо быть очень аккуратным при совместном использовании агрегатных функций и объединений. Обычно избежать ошибок, обусловленных дублированием строк, возникающим при объединении, можно двумя способами: или просто использовать в вызове агрегатной функции ключевое слово <code class="highlighter-rouge">DISTINCT</code>, чтобы в вычислении участвовали только уникальные экземпляры значений, или сначала провести агрегацию (во вложенном запросе), а потом объединение.</p>

<h5 id="mysql-и-postgresql">MySQL и PostgreSQL</h5>

<pre><code class="language-SQL">  select deptno,
         sum(distinct sal) as total_sal,
         sum(bonus) as total_bonus
  from (
    select e.empno,
           e.ename,
           e.sal,
           e.deptno,
           e.sal*case when eb.type = 1 then .1
            when eb.type = 2 then .2
            else .3
          end as bonus
    from emp e, emp_bonus eb
    where e.empno = eb.empno
      and e.deptno = 10
  ) x
  group by deptno
</code></pre>

<h5 id="db2-oracle-и-sql-server">DB2, Oracle и SQL Server</h5>

<pre><code class="language-SQL">  select distinct deptno, total_sal, total_bonus
  from (
    select e.empno,
           e.ename,
           sum(distinct e.sal) over (partition by e.deptno) as total_sal,
           e.deptno,
           sum(e.sal*case when eb.type = 1 then .1
            when eb.type = 2 then .2
            else .3 end) over(partition by deptno) as total_bonus
    from emp e, emp_bonus eb
    where e.empno = eb.empno
    and e.deptno = 10
  ) x
</code></pre>

<h4 id="внешнее-объединение-при-использовании-агрегатных-функций-стр-90">Внешнее объединение при использовании агрегатных функций (стр. 90)</h4>

<pre><code class="language-SQL">  select deptno,
         sum(distinct sal) as total_sal,
         sum(bonus) as total_bonus
  from (
    select e.empno,
     e.ename,
     e.sal,
     e.deptno,
     e.sal*case when eb.type is null then 0
      when eb.type = 1 then .1
      when eb.type = 2 then .2
      else .3
    end as bonus
    from emp e left outer join emp_bonus eb
      on (e.empno = eb.empno)
    where e.deptno = 10
  )
  group by deptno
</code></pre>

<p>Можно также использовать оконную функцию <code class="highlighter-rouge">SUM OVER</code>:</p>

<pre><code class="language-SQL">  select distinct deptno, total_sal, total_bonus
  from (
    select e.empno,
      e.ename,
      sum(distinct e.sal) over(partition by e.deptno) as total_sal,
      e.deptno,
      sum(e.sal*case when eb.type is null then 0
        when eb.type = 1 then .1
        when eb.type = 2 then .2
        else .3
      end) over (partition by deptno) as total_bonus
  from emp e left outer join emp_bonus eb
    on (e.empno = eb.empno)
  where e.deptno = 10
  ) x
</code></pre>

<h4 id="возвращение-отсутствующих-данных-из-нескольких-таблиц-стр-93">Возвращение отсутствующих данных из нескольких таблиц (стр. 93)</h4>

<pre><code class="language-SQL">  select d.deptno,d.dname,e.ename
  from dept d full outer join emp e
    on (d.deptno=e.deptno)
</code></pre>

<pre><code class="language-SQL">  select d.deptno, d.dname, e.ename
    from dept d right outer join emp e
      on (d.deptno=e.deptno)

  union

  select d.deptno,d.dname,e.ename
  from dept d left outer join emp e
    on (d.deptno=e.deptno)
</code></pre>

<h4 id="значения-null-в-операциях-и-сравнениях-стр-97">Значения NULL в операциях и сравнениях (стр. 97)</h4>

<pre><code class="language-SQL">  select ename,comm
  from emp
  where coalesce(comm,0) &lt; ( select comm
    from emp
    where ename = 'WARD' )
</code></pre>

<h3 id="вставка-обновление-удаление-стр-99">Вставка, обновление, удаление (стр. 99)</h3>

<h4 id="вставка-новой-записи-стр-100">Вставка новой записи (стр. 100)</h4>

<pre><code class="language-SQL">  insert into dept (deptno, dname, loc) values (50, 'PROGRAMMING', 'BALTIMORE')
</code></pre>

<h4 id="вставка-значений-по-умолчанию-стр-100">Вставка значений по умолчанию (стр. 100)</h4>

<pre><code class="language-SQL">  insert into D values (default)
</code></pre>

<h4 id="переопределение-значения-по-умолчанию-значением-null-стр-102">Переопределение значения по умолчанию значением NULL (стр. 102)</h4>

<pre><code class="language-SQL">  insert into d (id, foo) values (null, 'Brighten')
</code></pre>

<h4 id="копирование-строк-из-одной-таблицы-в-другую-стр-103">Копирование строк из одной таблицы в другую (стр. 103)</h4>

<pre><code class="language-SQL">  insert into dept_east (deptno, dname, loc)
    select deptno, dname, loc
    from dept
    where loc in ( 'NEW YORK', 'BOSTON' )
</code></pre>

<h4 id="копирование-описания-таблицы-стр-103">Копирование описания таблицы (стр. 103)</h4>

<h5 id="db2">DB2</h5>

<pre><code class="language-SQL">  create table dept_2 like dept
</code></pre>

<h5 id="oracle-mysql-и-postgresql">Oracle, MySQL и PostgreSQL</h5>

<pre><code class="language-SQL">  create table dept_2 as select * from dept where 1 = 0
</code></pre>

<h4 id="вставка-в-несколько-таблиц-одновременно-стр-104">Вставка в несколько таблиц одновременно (стр. 104)</h4>

<h5 id="oracle-1">Oracle</h5>

<pre><code class="language-SQL">  insert all
    when loc in ('NEW YORK','BOSTON') then
      into dept_east (deptno,dname,loc) values (deptno,dname,loc)
    when loc = 'CHICAGO' then
      into dept_mid (deptno,dname,loc) values (deptno,dname,loc)
    else
      into dept_west (deptno,dname,loc) values (deptno,dname,loc)
  select deptno,dname,loc
  from dept
</code></pre>

<h5 id="mysql-postgresql-и-sql-server">MySQL, PostgreSQL и SQL Server</h5>

<p>На момент написания данной книги эти производители не поддерживали вставки в несколько таблиц.</p>

<h4 id="блокировка-вставки-в-определенные-столбцы-стр-106">Блокировка вставки в определенные столбцы (стр. 106)</h4>

<p>Создайте представление, базированное на данной таблице, содержащее столбцы, доступные для вставки. Затем обеспечьте, чтобы вся вставка осуществлялась только посредством этого представления.</p>

<pre><code class="language-SQL">  create view new_emps as
    select empno, ename, job
    from emp
</code></pre>

<h4 id="изменение-записей-в-таблице-стр-107">Изменение записей в таблице (стр. 107)</h4>

<pre><code class="language-SQL">  update emp
    set sal = sal*1.10
  where deptno = 20
</code></pre>

<h4 id="обновление-в-случае-существования-соответствующих-строк-в-другой-таблице-стр-109">Обновление в случае существования соответствующих строк в другой таблице (стр. 109)</h4>

<pre><code class="language-SQL">  update emp
  set sal=sal*1.20
  where empno in ( select empno from emp_bonus )
</code></pre>

<h4 id="обновление-значениями-из-другой-таблицы-стр-109">Обновление значениями из другой таблицы (стр. 109)</h4>

<h5 id="db2-и-mysql">DB2 и MySQL</h5>

<pre><code class="language-SQL">  update emp e set (e.sal,e.comm) = (select ns.sal, ns.sal/2
    from new_sal ns
    where ns.deptno=e.deptno)
  where exists ( select null
    from new_sal ns
    where ns.deptno = e.deptno )
</code></pre>

<h5 id="postgresql">PostgreSQL</h5>

<pre><code class="language-SQL">  update emp
  set sal = ns.sal, comm = ns.sal/2
  from new_sal ns
  where ns.deptno = emp.deptno
</code></pre>

<h4 id="слияние-записей-стр-113">Слияние записей (стр. 113)</h4>

<p>В настоящее время Oracle является единственной СУБД1, имеющей выражение для решения этой задачи. Это выражение – <code class="highlighter-rouge">MERGE</code></p>

<pre><code class="language-SQL">  merge into emp_commission ec
  using (select * from emp) emp on (ec.empno=emp.empno)
    when matched then
      update set ec.comm = 1000
      delete where (sal &lt; 2000)
    when not matched then
      insert (ec.empno,ec.ename,ec.deptno,ec.comm)
      values (emp.empno,emp.ename,emp.deptno,emp.comm)
</code></pre>

<h4 id="удаление-всех-записей-из-таблицы-стр-115">Удаление всех записей из таблицы (стр. 115)</h4>

<pre><code class="language-SQL">  delete from emp
</code></pre>

<h4 id="удаление-определенных-записей-стр-116">Удаление определенных записей (стр. 116)</h4>

<pre><code class="language-SQL">  delete from emp where deptno = 10
</code></pre>

<h4 id="удаление-одной-записи-стр-116">Удаление одной записи (стр. 116)</h4>

<pre><code class="language-SQL">  delete from emp where empno = 7782
</code></pre>

<h4 id="удаление-записей-которые-нарушают-ссылочную-целостность-стр-117">Удаление записей, которые нарушают ссылочную целостность (стр. 117)</h4>

<p>Требуется удалить записи из таблицы, если они ссылаются на несуществующие записи другой таблицы.</p>

<pre><code class="language-SQL">  delete from emp
  where not exists (
    select * from dept
    where dept.deptno = emp.deptno
  )
</code></pre>

<pre><code class="language-SQL">  delete from emp
  where deptno not in (select deptno from dept)
</code></pre>

<h4 id="уничтожение-дублирующихся-записей-стр-118">Уничтожение дублирующихся записей (стр. 118)</h4>

<pre><code class="language-SQL">  delete from dupes
  where id not in ( select min(id)
    from dupes
    group by name )
</code></pre>

<h4 id="удаление-записей-на-которые-есть-ссылки-в-другой-таблице-стр-119">Удаление записей, на которые есть ссылки в другой таблице (стр. 119)</h4>

<pre><code class="language-SQL">  delete from emp
  where deptno in ( select deptno
    from dept_accidents
    group by deptno
    having count(*) &gt;= 3 )
</code></pre>

<h3 id="5-запросы-на-получение-метаданных-стр-121">5 Запросы на получение метаданных (стр. 121)</h3>

<h4 id="как-получить-список-таблиц-схемы-стр-121">Как получить список таблиц схемы (стр. 121)</h4>

<pre><code class="language-SQL">  select table_name
  from information_schema.tables
  where table_schema = 'SMEAGOL'
</code></pre>

<h4 id="как-получить-список-столбцов-таблицы-стр-122">Как получить список столбцов таблицы (стр. 122)</h4>

<pre><code class="language-SQL">  select column_name, data_type, ordinal_position
  from information_schema.columns
  where table_schema = 'SMEAGOL'
  and table_name = 'EMP'
</code></pre>

<h4 id="как-получить-список-индексированных-столбцов-таблицы-стр-123">Как получить список индексированных столбцов таблицы (стр. 123)</h4>

<h4 id="mysql">MySQL</h4>

<pre><code class="language-SQL">  select a.tablename,a.indexname,b.column_name
  from pg_catalog.pg_indexes a, information_schema.columns b
  where a.schemaname = 'SMEAGOL'
  and a.tablename = b.table_name
</code></pre>

<h4 id="postgresql-1">PostgreSQL</h4>

<pre><code class="language-SQL">  show index from emp
</code></pre>

<h4 id="как-получить-список-ограничений-наложенных-на-таблицу-стр-125">Как получить список ограничений, наложенных на таблицу (стр. 125)</h4>

<h5 id="postgresql-mysql-и-sql-server">PostgreSQL, MySQL и SQL Server</h5>

<pre><code class="language-SQL">  select a.table_name,
    a.constraint_name,
    b.column_name,
    a.constraint_type
  from information_schema.table_constraints a,
    information_schema.key_column_usage b
  where a.table_name = 'EMP'
    and a.table_schema = 'SMEAGOL'
    and a.table_name = b.table_name
    and a.table_schema = b.table_schema
    and a.constraint_name = b.constraint_name
</code></pre>

<h3 id="6-работа-со-строками-стр-134">6 Работа со строками (стр. 134)</h3>

<h4 id="проход-строки-стр-135">Проход строки (стр. 135)</h4>

<pre><code class="language-SQL">  select substr(e.ename,iter.pos,1) as C
    from (select ename from emp where ename = 'KING') e,
      (select id as pos from t10) iter where iter.pos &lt;= length(e.ename)
</code></pre>

<h4 id="как-вставить-кавычки-в-строковые-литералы-стр-135">Как вставить кавычки в строковые литералы (стр. 135)</h4>

<pre><code class="language-SQL">  select 'g''day mate' qmarks from t1
</code></pre>

<pre><code class="language-SQL">  select 'beavers'' teeth' from t1
</code></pre>

<pre><code class="language-SQL">  select '''' from t1
</code></pre>

<h4 id="как-подсчитать-сколько-раз-символ-встречается-в-строке-стр-138">Как подсчитать, сколько раз символ встречается в строке (стр. 138)</h4>

<p>Чтобы определить количество запятых в строке, <code class="highlighter-rouge">10,CLARK,MANAGER</code> вычтем ее длину без
запятых из исходной длины.</p>

<pre><code class="language-SQL">  select (length('10,CLARK,MANAGER') - length(replace('10,CLARK,MANAGER',',','')))/length(',')
  as cnt
  from t1
</code></pre>

<h4 id="удаление-из-строки-ненужных-символов-стр-139">Удаление из строки ненужных символов (стр. 139)</h4>

<h5 id="mysql-и-sql-server-2">MySQL и SQL Server</h5>

<pre><code class="language-SQL">  select ename,
    replace(
      replace(
        replace(
          replace(
            replace(ename,'A',''),'E',''),'I',''),'O',''),'U','')
    as stripped1,
    sal,
    replace(sal,0,'') stripped2
  from emp
</code></pre>

<h5 id="oracle-и-postgresql">Oracle и PostgreSQL</h5>

<pre><code class="language-SQL">  select ename, replace(translate(ename,'AEIOU','aaaaa'),'a')
    as stripped1,
    sal,
    replace(sal,0,'') as stripped2
  from emp
</code></pre>

<h4 id="разделение-числовых-и-символьных-данных-стр-141">Разделение числовых и символьных данных (стр. 141)</h4>

<h5 id="postgresql-2">PostgreSQL</h5>

<pre><code class="language-SQL">  select replace(
    translate(data,'0123456789','0000000000'),'0','') as ename,
    cast(
      replace(
        translate(lower(data),
          'abcdefghijklmnopqrstuvwxyz',
          rpad('z',26,'z')),'z','') as integer) as sal
  from (
    select ename||sal as data
    from emp
  ) x
</code></pre>

<h4 id="извлечение-инициалов-из-имени-стр-150">Извлечение инициалов из имени (стр. 150)</h4>

<h5 id="mysql-1">MySQL</h5>

<pre><code class="language-SQL">  select case
    when cnt = 2 then
      trim(trailing '.' from
        concat_ws('.', substr(substring_index(name,' ',1),1,1), substr(name,
          length(substring_index(name,' ',1))+2,1),
          substr(substring_index(name,' ',1),1,1),
          '.'))
    else
      trim(trailing '.' from
        concat_ws('.',
          substr(substring_index(name,' ',1),1,1),
          substr(substring_index(name,' ',1),1,1)
        )
      )
    end as initials
  from (
    select name,length(name)length(replace(name,' ','')) as cnt
    from (
      select replace('Stewie Griffin','.','') as name from t1
    )y
  )x
</code></pre>

<h5 id="oracle-и-postgresql-1">Oracle и PostgreSQL</h5>

<pre><code class="language-SQL">  select replace(
    replace(
      translate(replace('Stewie Griffin', '.', ''),
      'abcdefghijklmnopqrstuvwxyz',
    rpad('#',26,'#') ), '#','' ),' ','.' ) ||'.'
  from t1
</code></pre>

<h4 id="упорядочивание-по-частям-строки-стр-154">Упорядочивание по частям строки (стр. 154)</h4>

<p>Требуется упорядочить строки по последним двум символам имени</p>

<pre><code class="language-SQL">  select ename
  from emp
  order by substr(ename,length(ename)1,2)
</code></pre>

<h4 id="упорядочивание-по-числу-в-строке-стр-155">Упорядочивание по числу в строке (стр. 155)</h4>

<h5 id="postgresql-3">PostgreSQL</h5>

<pre><code class="language-SQL">  select data
  from V
  order by
  cast(
    replace(
    translate(data,
      replace(
        translate(data,'0123456789','##########'),
          '#',''),rpad('#',20,'#')),'#','') as integer)
</code></pre>
<h5 id="mysql-и-sql-server-3">MySQL и SQL Server</h5>

<p>На момент написания данной книги ни один из данных производителей не поддерживает функцию TRANSLATE.</p>

<h4 id="создание-списка-с-разделителями-из-строк-таблицы-стр-161">Создание списка с разделителями из строк таблицы (стр. 161)</h4>

<h5 id="mysql-2">MySQL</h5>

<pre><code class="language-SQL">  select deptno,
    group_concat(ename order by empno separator ',') as emps
  from emp
  group by deptno
</code></pre>

<h4 id="преобразование-данных-с-разделителями-в-список-оператора-in-со-множеством-значений-стр-168">Преобразование данных с разделителями в список оператора IN со множеством значений (стр. 168)</h4>

<h5 id="mysql-3">MySQL</h5>

<pre><code class="language-SQL">  select empno, ename, sal, deptno
  from emp
  where empno in (
    select substring_index(
      substring_index(list.vals,',',iter.pos),',',1) empno
    from (select id pos from t10) as iter,
      (select '7654,7698,7782,7788' as vals
      from t1) list
      where iter.pos &lt;= (length(list.vals)length(replace(list.vals,',','')))+1
  ) x
</code></pre>

<h4 id="упорядочение-строки-в-алфавитном-порядке-стр-174">Упорядочение строки в алфавитном порядке (стр. 174)</h4>

<h5 id="mysql-4">MySQL</h5>

<pre><code class="language-SQL">  select ename, group_concat(c order by c separator '')
  from (
    select ename, substr(a.ename,iter.pos,1) c
    from emp a,
    ( select id pos from t10 ) iter
    where iter.pos &lt;= length(a.ename)
  ) x
  group by ename
</code></pre>

<h4 id="выявление-строк-которые-могут-быть-интерпретированы-как-числа-стр-180">Выявление строк, которые могут быть интерпретированы как числа (стр. 180)</h4>

<h5 id="mysql-5">MySQL</h5>

<pre><code class="language-SQL">  select cast(group_concat(c order by pos separator '') as unsigned) as MIXED1
  from (
    select v.mixed, iter.pos, substr(v.mixed,iter.pos,1) as c
    from V,
    ( select id pos from t10 ) iter
      where iter.pos &lt;= length(v.mixed) and ascii(substr(v.mixed,iter.pos,1)) between 48 and 57
    ) y
  group by mixed
  order by 1
</code></pre>

<h4 id="извлечение-nной-подстроки-с-разделителями-стр-187">Извлечение nной подстроки с разделителями (стр. 187)</h4>

<h5 id="mysql-6">MySQL</h5>

<pre><code class="language-SQL">  select name
  from (
    select iter.pos,
      substring_index(
        substring_index(src.name,',',iter.pos),',',1) name
    from V src,
      (select id pos from t10) iter,
      where iter.pos &lt;= length(src.name)length(replace(src.name,',',''))
    ) x
  where pos = 2
</code></pre>

<h3 id="7-работа-с-числами">7 Работа с числами</h3>

<h4 id="вычисление-среднего">Вычисление среднего</h4>

<pre><code class="language-SQL">  select avg(sal) as avg_sal from emp
</code></pre>

<h4 id="поиск-минимальногомаксимального-значения-столбца">Поиск минимального/максимального значения столбца</h4>

<pre><code class="language-SQL">  select min(sal) as min_sal, max(sal) as max_sal from emp
</code></pre>

<h4 id="вычисление-суммы-значений-столбца">Вычисление суммы значений столбца</h4>

<pre><code class="language-SQL">  select sum(sal) from emp
</code></pre>

<h4 id="вычисление-моды-стр-213">Вычисление моды (стр. 213)</h4>

<p>мода (mode) в математике – это наиболее часто встречающийся элемент рассматриваемого множества данных</p>

<pre><code class="language-SQL">  select sal
  from emp
  where deptno = 20
  group by sal
  having count(*) &gt;= all ( select count(*)
    from emp
    where deptno = 20
    group by sal )
</code></pre>

<h4 id="вычисление-медианы-стр-216">Вычисление медианы (стр. 216)</h4>

<p>медиана (median) – это значение среднего члена множества упорядоченных элементов</p>

<pre><code class="language-SQL">  select avg(sal)
  from (
    select e.sal
    from emp e, emp d
    where e.deptno = d.deptno and e.deptno = 20
    group by e.sal
    having sum(case when e.sal = d.sal then 1 else 0 end) &gt;= abs(sum(sign(e.sal  d.sal)))
  )
</code></pre>

<h4 id="вычисление-доли-от-целого-в-процентном-выражении-стр-220">Вычисление доли от целого в процентном выражении (стр. 220)</h4>

<pre><code class="language-SQL">  select (sum(case when deptno = 10 then sal end)/sum(sal))*100 as pct
  from emp
</code></pre>

<h4 id="агрегация-столбцов-которые-могут-содержать-null-значения-стр-223">Агрегация столбцов, которые могут содержать NULL значения (стр. 223)</h4>

<pre><code class="language-SQL">  select avg(coalesce(comm,0)) as avg_comm
  from emp
  where deptno=30
</code></pre>

<h4 id="вычисление-среднего-без-учета-наибольшего-и-наименьшего-значений-стр-224">Вычисление среднего без учета наибольшего и наименьшего значений (стр. 224)</h4>

<pre><code class="language-SQL">select avg(sal)
from emp
where sal not in (
  (select min(sal) from emp),
  (select max(sal) from emp)
)
</code></pre>

<h4 id="преобразование-буквенноцифровых-строк-в-числа-стр-226">Преобразование буквенноцифровых строк в числа (стр. 226)</h4>

<h5 id="oracle-и-postgresql-2">Oracle и PostgreSQL</h5>

<pre><code class="language-SQL">  select cast(
    replace(
      translate( 'paul123f321', 'abcdefghijklmnopqrstuvwxyz', rpad('#',26,'#')),'#','') as integer ) as num
  from t1
</code></pre>

<h5 id="mysql-and-sql-server">MySQL and SQL Server</h5>
<p>Решение не предоставляется, поскольку на момент написания данной книги ни один из этих производителей не поддерживает функцию <code class="highlighter-rouge">TRANSLATE</code>.</p>

<h4 id="изменение-значений-в-текущей-сумме-стр-228">Изменение значений в текущей сумме (стр. 228)</h4>

<pre><code class="language-SQL">  select
    case when v1.trx = 'PY'
      then 'PAYMENT'
      else 'PURCHASE'
    end as trx_type,
    v1.amt,
    (select sum(
      case when v2.trx = 'PY'
      then v2.amt else v2.amt
    end
    )
  from V v2
  where v2.id &lt;= v1.id) as balance
  from V v1
</code></pre>

<h3 id="8-арифметика-дат">8 Арифметика дат</h3>

<h4 id="добавление-и-вычитание-дней-месяцев-и-лет-стр-231">Добавление и вычитание дней, месяцев и лет (стр. 231)</h4>

<h5 id="mysql-7">MySQL</h5>

<pre><code class="language-SQL">
  select hiredate - interval 5 day as hd_minus_5D,
    hiredate + interval 5 day as hd_plus_5D,
    hiredate - interval 5 month as hd_minus_5M,
    hiredate + interval 5 month as hd_plus_5M,
    hiredate - interval 5 year as hd_minus_5Y,
    hiredate + interval 5 year as hd_plus_5Y
  from emp
  where deptno=10

</code></pre>

<h4 id="определение-количества-дней-между-двумя-датами-стр-234">Определение количества дней между двумя датами (стр. 234)</h4>

<h5 id="mysql-8">MySQL</h5>

<pre><code class="language-SQL">  select datediff(day,allen_hd,ward_hd)
  from (
    select hiredate as ward_hd
    from emp
    where ename = 'WARD'
  ) x,
  (
    select hiredate as allen_hd
    from emp
    where ename = 'ALLEN'
  ) y
</code></pre>

<h4 id="определение-количества-рабочих-дней-между-двумя-датами-стр-236">Определение количества рабочих дней между двумя датами (стр. 236)</h4>

<p>Для формирования необходимого числа строк (дней) между двумя датами используйте сводную таблицу T500. Затем подсчитайте количество дней, не являющихся выходными. Добавление дней к каждой дате реализуйте с помощью функции <code class="highlighter-rouge">DATE_ADD</code>. Воспользуйтесь функцией <code class="highlighter-rouge">DATE_FORMAT</code> (формат даты) для получения названия дня недели для каждой даты:</p>

<h5 id="mysql-9">MySQL</h5>

<pre><code class="language-SQL">  select sum(
    case when date_format(date_add(jones_hd, interval t500.id1 DAY),'%a') in ( 'Sat','Sun' )
    then 0 else 1
  end) as days
  from (
    select 
      max(case when ename = 'BLAKE'
        then hiredate
      end) as blake_hd,
      max(case when ename = 'JONES'
        then hiredate
      end) as jones_hd
    from emp
  where ename in ( 'BLAKE','JONES' )
  ) x,
  t500
  where t500.id &lt;= datediff(blake_hd,jones_hd)+1
</code></pre>

<h4 id="определение-количества-месяцев-или-лет-между-двумя-датами-стр-241">Определение количества месяцев или лет между двумя датами (стр. 241)</h4>

<h5 id="mysql-10">MySQL</h5>

<pre><code class="language-SQL">  select mnth, mnth/12
  from (
    select (year(max_hd)  year(min_hd))*12 + (month(max_hd)  month(min_hd)) as mnth
    from (
      select min(hiredate) as min_hd, max(hiredate) as max_hd
      from emp
    ) x
  ) y
</code></pre>

<h4 id="как-подсчитать-сколько-раз-в-году-повторяется-каждый-день-недели-стр-246">Как подсчитать, сколько раз в году повторяется каждый день недели (стр. 246)</h4>

<p>Чтобы найти, сколько раз повторяется каждый день недели за год, необходимо:</p>
<ol>
  <li>Сгенерировать все возможные даты года.</li>
  <li>Отформатировать даты таким образом, чтобы в них был указан со!
ответствующий день недели.</li>
  <li>Подсчитать, сколько раз за год встречается название каждого дня
недели.</li>
</ol>

<h4 id="определение-интервала-времени-в-днях-между-текущей-и-следующей-записями-стр-258">Определение интервала времени в днях между текущей и следующей записями (стр. 258)</h4>

<pre><code class="language-SQL">  select x.*, datediff(day,x.hiredate,x.next_hd) diff
  from (
    select e.deptno, e.ename, e.hiredate,
      (select min(d.hiredate) from emp d
        where d.hiredate &gt; e.hiredate) next_hd
        from emp e
    where e.deptno = 10
  ) x
</code></pre>

<h3 id="9-работа-с-датами-стр-264">9 Работа с датами (стр. 264)</h3>

<h4 id="как-определить-является-ли-год-високосным-стр-265">Как определить, является ли год високосным (стр. 265)</h4>

<p>проверяется последний день февраля; если он является 29м днем, то текущий год – високосный.</p>

<pre><code class="language-SQL">  select day(
    last_day(
      date_add(
        date_add(
          date_add(current_date,
            interval dayofyear(current_date) day),
              interval 1 day),
                interval 1 month))) dy
  from t1
</code></pre>

<h4 id="как-определить-количество-дней-в-году-стр-272">Как определить количество дней в году (стр. 272)</h4>

<ol>
  <li>Определение первого дня текущего года.</li>
  <li>Добавление одного года к этой дате (для получения первого дня следующего года).</li>
  <li>Вычитание текущего года из результата шага 2.</li>
</ol>

<pre><code class="language-SQL">  select datediff((curr_year + interval 1 year),curr_year)
  from (
    select adddate(current_date,dayofyear(current_date)+1) curr_year
    from t1
  ) x
</code></pre>

<h4 id="извлечение-единиц-времени-из-даты-стр-275">Извлечение единиц времени из даты (стр. 275)</h4>

<h5 id="mysql-11">MySQL</h5>

<pre><code class="language-SQL">  select date_format(current_timestamp,'%k') hr,
    date_format(current_timestamp,'%i') min,
    date_format(current_timestamp,'%s') sec,
    date_format(current_timestamp,'%d') dy,
    date_format(current_timestamp,'%m') mon,
    date_format(current_timestamp,'%Y') yr
  from t1
</code></pre>

<h4 id="определение-первого-и-последнего-дней-месяца-стр-277">Определение первого и последнего дней месяца (стр. 277)</h4>

<h5 id="mysql-12">MySQL</h5>

<pre><code class="language-SQL">  select date_add(current_date,
    interval -day(current_date)+1 day) firstday,
    last_day(current_date) lastday
  from t1
</code></pre>

<h4 id="выбор-всех-дат-года-выпадающих-на-определенный-день-недели-стр-280">Выбор всех дат года, выпадающих на определенный день недели (стр. 280)</h4>

<h5 id="mysql-13">MySQL</h5>

<pre><code class="language-SQL">  select dy
  from (
    select adddate(x.dy,interval t500.id1 day) dy
    from (
      select dy, year(dy) yr
        from (
          select adddate(
            adddate(current_date,
             interval dayofyear(current_date) day),
               interval 1 day ) dy
          from t1
        ) tmp1
      ) x,
      t500
    where year(adddate(x.dy,interval t500.id1 day)) = x.yr
    ) tmp2
  where dayname(dy) = 'Friday'
</code></pre>

<h4 id="определение-дат-первого-и-последнего-появления-заданного-дня-недели-стр-287">Определение дат первого и последнего появления заданного дня недели (стр. 287)</h4>

<h5 id="mysql-14">MySQL</h5>

<p>Используйте функцию <code class="highlighter-rouge">ADDDATE</code>, чтобы получить первый день месяца. После этого путем простых вычислений над числовыми значениями дней недели (Вс.–Сб. соответствуют 1–7) находите первый и последний понедельники текущего месяца:</p>

<pre><code class="language-SQL">  select first_monday,
    case month(adddate(first_monday,28))
    when mth then adddate(first_monday,28)
    else adddate(first_monday,21)
  end last_monday
  from (
    select case sign(dayofweek(dy)2)
      when 0 then dy
      when 1 then adddate(dy,abs(dayofweek(dy)2))
      when 1 then adddate(dy,(7(dayofweek(dy)2)))
    end first_monday, mth
    from (
      select adddate(adddate(current_date,day(current_date)),1) dy, month(current_date) mth
      from t1
    ) x
  ) y
</code></pre>

<h4 id="создание-календаря-стр-295">Создание календаря (стр. 295)</h4>

<h5 id="mysql-15">MySQL</h5>

<pre><code class="language-SQL">  select max(case dw when 2 then dm end) as Mo,
    max(case dw when 3 then dm end) as Tu,
    max(case dw when 4 then dm end) as We,
    max(case dw when 5 then dm end) as Th,
    max(case dw when 6 then dm end) as Fr,
    max(case dw when 7 then dm end) as Sa,
    max(case dw when 1 then dm end) as Su
  from (
    select date_format(dy,'%u') wk,
      date_format(dy,'%d') dm,
      date_format(dy,'%w')+1 dw
    from (
      select adddate(x.dy,t500.id1) dy,
        x.mth
      from (
        select adddate(current_date,dayofmonth(current_date)+1) dy,
          date_format(
          adddate(current_date,
          dayofmonth(current_date)+1),
          '%m') mth
        from t1
      ) x, t500
    where t500.id &lt;= 31 and date_format(adddate(x.dy,t500.id1),'%m') = x.mth ) y ) z
  group by wk
  order by wk
</code></pre>

<h4 id="получение-дат-начала-и-конца-кварталов-года-стр-314">Получение дат начала и конца кварталов года (стр. 314)</h4>

<h5 id="mysql-16">MySQL</h5>

<pre><code class="language-SQL">  select quarter(adddate(dy,1)) QTR, date_add(dy,interval 3 month) Q_start, adddate(dy,1) Q_end
  from (
    select date_add(dy,interval (3*id) month) dy
    from (
      select id, adddate(current_date,dayofyear(current_date)+1) dy
      from t500
      where id &lt;= 4
    ) x
  ) y
</code></pre>

<h4 id="определение-дат-начала-и-окончания-заданного-квартала-стр-320">Определение дат начала и окончания заданного квартала (стр. 320)</h4>

<p>Год и квартал заданы в формате YYYYQ (четыре разряда – год, один разряд – квартал)</p>

<h5 id="mysql-17">MySQL</h5>

<pre><code class="language-SQL">  select date_add(adddate(q_end,day(q_end)+1),
    interval 2 month) q_start,
    q_end
  from (
    select last_day(str_to_date(concat(substr(yrq,1,4),mod(yrq,10)*3),'%Y%m')) q_end
    from (
      select 20051 as yrq from t1 union all
      select 20052 as yrq from t1 union all
      select 20053 as yrq from t1 union all
      select 20054 as yrq from t1
    ) x
  ) y
</code></pre>

<h4 id="дополнение-отсутствующих-дат-стр-327">Дополнение отсутствующих дат (стр. 327)</h4>

<h5 id="mysql-18">MySQL</h5>

<pre><code class="language-SQL">  select z.mth, count(e.hiredate) num_hired
  from (
    select date_add(min_hd,interval t500.id1 month) mth
    from (
      select min_hd, date_add(max_hd,interval 11 month) max_hd
      from (
        select adddate(min(hiredate),dayofyear(min(hiredate))+1) min_hd,
          adddate(max(hiredate),dayofyear(max(hiredate))+1) max_hd
        from emp
      ) x
    ) y, t500
  where date_add(min_hd,interval t500.id1 month) &lt;= max_hd) z 
  left join emp e on (z.mth = adddate(date_add(last_day(e.hiredate),interval 1 month),1))
  group by z.mth
  order by 1
</code></pre>

<h4 id="поиск-по-заданным-единицам-времени-стр-337">Поиск по заданным единицам времени (стр. 337)</h4>

<h5 id="db2-и-mysql-1">DB2 и MySQL</h5>

<pre><code class="language-SQL">  select ename
  from emp
  where monthname(hiredate) in ('February','December') or dayname(hiredate) = 'Tuesday'
</code></pre>

<h4 id="сравнение-строк-по-определенной-части-даты-стр-339">Сравнение строк по определенной части даты (стр. 339)</h4>

<h5 id="mysql-19">MySQL</h5>

<pre><code class="language-SQL">  select concat(a.ename, ' was hired on the same month and weekday as ', b.ename) msg
  from emp a, emp b
  where date_format(a.hiredate,'%w%M') = date_format(b.hiredate,'%w%M')
    and a.empno &lt; b.empno
  order by a.ename
</code></pre>

<h4 id="выявление-наложений-диапазонов-дат-стр-342">Выявление наложений диапазонов дат (стр. 342)</h4>

<h5 id="mysql-20">MySQL</h5>

<pre><code class="language-SQL">  select a.empno,a.ename,concat('project ',b.proj_id,' overlaps project ',a.proj_id) as msg
  from emp_project a,emp_project b
  where a.empno = b.empno
    and b.proj_start &gt;= a.proj_start
    and b.proj_start &lt;= a.proj_end
    and a.proj_id != b.proj_id
</code></pre>

<h3 id="10-работа-с-диапазонами-данных-стр-348">10 Работа с диапазонами данных (стр. 348)</h3>

<h4 id="поиск-диапазона-последовательных-значений-стр-348">Поиск диапазона последовательных значений (стр. 348)</h4>

<pre><code class="language-SQL">  select v1.proj_id,
  v1.proj_start,
  v1.proj_end
  from V v1, V v2
  where v1.proj_end = v2.proj_start
</code></pre>

<h4 id="вычисление-разности-между-значениями-строк-одной-группы-или-сегмента-стр-354">Вычисление разности между значениями строк одной группы или сегмента (стр. 354)</h4>

<h5 id="db2-mysql-postgresql-и-sql-server">DB2, MySQL, PostgreSQL и SQL Server</h5>

<pre><code class="language-SQL">  select deptno,ename,hiredate,sal,coalesce(cast(salnext_sal as char(10)),'N/A') as diff
  from (
    select e.deptno,e.ename,e.hiredate,e.sal,
      (select min(sal) from emp d
      where d.deptno=e.deptno
        and d.hiredate =
          (select min(hiredate) from emp d
            where e.deptno=d.deptno and d.hiredate &gt; e.hiredate)) as next_sal
    from emp e
  ) x
</code></pre>

<h5 id="oracle-2">Oracle</h5>

<pre><code class="language-SQL">  select deptno,ename,sal,hiredate,lpad(nvl(to_char(salnext_sal),'N/A'),10) diff
  from (
    select deptno,ename,sal,hiredate,lead(sal)over(partition by deptno order by hiredate) next_sal
  from emp
  )
</code></pre>

<h4 id="определение-начала-и-конца-диапазона-последовательных-значений-стр-363">Определение начала и конца диапазона последовательных значений (стр. 363)</h4>

<pre><code class="language-SQL">  create view v2
  as
  select a.*,
    case
      when (
        select b.proj_id
        from V b
        where a.proj_start = b.proj_end
      )
      is not null then 0 else 1
    end as flag
  from V a


  select proj_grp,min(proj_start) as proj_start,max(proj_end) as proj_end
  from (
  select a.proj_id,a.proj_start,a.proj_end,
    (select sum(b.flag)
      from V2 b
      where b.proj_id &lt;= a.proj_id) as proj_grp
      from V2 a
    ) x
  group by proj_grp
</code></pre>

<h4 id="вставка-пропущенных-значений-диапазона-стр-368">Вставка пропущенных значений диапазона (стр. 368)</h4>

<pre><code class="language-SQL">  select y.yr, coalesce(x.cnt,0) as cnt
  from (
    select min_yearmod(cast(min_year as int),10)+rn as yr
    from (
      select (select min(extract(year from hiredate))
      from emp) as min_year,id1 as rn
  from t10) a) y
  left join
    (
      select extract(year from hiredate) as yr, count(*) as cnt
      from emp
      group by extract(year from hiredate)
    ) x
  on ( y.yr = x.yr )
</code></pre>

<h4 id="формирование-последовательности-числовых-значений-стр-373">Формирование последовательности числовых значений (стр. 373)</h4>

<pre><code class="language-SQL">  with x (id) as (
    select 1
    from t1

    union all

    select id+1
    from x
    where id+1 &lt;= 10
  )

  select * from x
</code></pre>

<h3 id="расширенный-поиск-стр-378">Расширенный поиск (стр. 378)</h3>

<h4 id="разбиение-результирующего-множества-на-страницы-стр-378">Разбиение результирующего множества на страницы (стр. 378)</h4>

<pre><code class="language-SQL">  select sal
  from emp
  order by sal limit 5 offset 0
</code></pre>

<h4 id="как-пропустить-n-строк-таблицы-стр-381">Как пропустить n строк таблицы (стр. 381)</h4>

<pre><code class="language-SQL">  select x.ename
  from (
    select a.ename,
      (select count(*)
      from emp b
      where b.ename &lt;= a.ename) as rn
    from emp a
  ) x
  where mod(x.rn,2) = 1
</code></pre>

<h4 id="использование-логики-or-во-внешних-объединениях-стр-384">Использование логики OR во внешних объединениях (стр. 384)</h4>

<pre><code class="language-SQL">  select e.ename, d.deptno, d.dname, d.loc
  from dept d left join emp e
    on (d.deptno = e.deptno
    and (e.deptno=10 or e.deptno=20))
  order by 2
</code></pre>

<h4 id="выявление-строк-со-взаимообратными-значениями-стр-387">Выявление строк со взаимообратными значениями (стр. 387)</h4>

<pre><code class="language-SQL">  select distinct v1.*
  from V v1, V v2
  where v1.test1 = v2.test2
    and v1.test2 = v2.test1
    and v1.test1 &lt;= v1.test2
</code></pre>

<h4 id="как-выбрать-записи-с-nым-количеством-наивысших-значений-стр-389">Как выбрать записи с nым количеством наивысших значений (стр. 389)</h4>

<pre><code class="language-SQL">select ename,sal
from (
  select (select count(distinct b.sal)
    from emp b
    where a.sal &lt;= b.sal) as rnk,
  a.sal,a.ename
  from emp a
)
where rnk &lt;= 5
</code></pre>

<h4 id="как-найти-записи-с-наибольшим-и-наименьшим-значениями-стр-391">Как найти записи с наибольшим и наименьшим значениями (стр. 391)</h4>

<pre><code class="language-SQL">  select ename
  from emp
  where sal in ( (select min(sal) from emp), (select max(sal) from emp) )
</code></pre>

<h4 id="сбор-информации-из-последующих-строк-стр-393">Сбор информации из последующих строк (стр. 393)</h4>

<pre><code class="language-SQL">select ename, sal, hiredate
from (
  select a.ename, a.sal, a.hiredate,
    (select min(hiredate) from emp b
    where b.hiredate &gt; a.hiredate
      and b.sal &gt; a.sal ) as next_sal_grtr,
    (select min(hiredate) from emp b
    where b.hiredate &gt; a.hiredate) as next_hire
from emp a ) x
where next_sal_grtr = next_hire
</code></pre>

<h4 id="смещение-значений-строк-стр-396">Смещение значений строк (стр. 396)</h4>

<pre><code class="language-SQL">  select e.ename, e.sal,
    coalesce(
      (select min(sal) from emp d where d.sal &gt; e.sal),
      (select min(sal) from emp)
    ) as forward,
    coalesce(
      (select max(sal) from emp d where d.sal &lt; e.sal),
      (select max(sal) from emp)
    ) as rewind
  from emp e
  order by 2
</code></pre>

<h4 id="ранжирование-результатов-стр-400">Ранжирование результатов (стр. 400)</h4>

<h5 id="db2-oracle-и-sql-server-1">DB2, Oracle и SQL Server</h5>

<pre><code class="language-SQL"> select dense_rank() over(order by sal) rnk, sal from emp
</code></pre>

<h5 id="mysql-и-postgresql-1">MySQL и PostgreSQL</h5>

<pre><code class="language-SQL">  select (select count(distinct b.sal)
    from emp b
    where b.sal &lt;= a.sal) as rnk,
    a.sal
  from emp a
</code></pre>

<h4 id="исключение-дубликатов-стр-401">Исключение дубликатов (стр. 401)</h4>

<pre><code class="language-SQL">  select distinct job from emp
</code></pre>

<pre><code class="language-SQL">  select job from emp group by job
</code></pre>

<h4 id="ход-конем-стр-403">Ход конем (стр. 403)</h4>

<p>Требуется получить множество, содержащее имя каждого служащего, отдел, в котором он работает, его заработную плату, дату его приема на работу и заработную плату сотрудника, принятого на работу последним в отделе.
  Значения столбца <strong>LATEST_SAL</strong> определяются в результате «хода конем», поскольку схема поиска их в таблице 
аналогична схеме перемещения шахматного коня.</p>

<pre><code class="language-SQL">  select e.deptno,
    e.ename,
    e.sal,
    e.hiredate,
    (select max(d.sal)
    from emp d
    where d.deptno = e.deptno
      and d.hiredate =
      (select max(f.hiredate)
      from emp f
      where f.deptno = e.deptno)) as latest_sal
  from emp e
  order by 1, 4 desc
</code></pre>

<h4 id="формирование-простых-прогнозов-стр-411">Формирование простых прогнозов (стр. 411)</h4>

<p>Исходя из текущих данных требуется получить дополнительные строки и столбцы, представляющие будущие действия.
Для каждой строки результирующего множества требуется возвратить три строки (строка плюс две дополнительные строки для каждого заказа). Кроме дополнительных строк, должны быть добавлены столбцы с предполагаемыми датами обработки заказов.</p>

<h5 id="postgresql-4">PostgreSQL</h5>

<pre><code class="language-SQL">  select id, order_date, process_date,
    case when gs.n &gt;= 2
      then process_date+1
      else null
    end as verified,
    case when gs.n = 3
      then process_date+2
      else null
    end as shipped
  from (
    select gs.id,
      current_date+gs.id as order_date,
      current_date+gs.id+2 as process_date
    from generate_series(1,3) gs (id)
  ) orders,
  generate_series(1,3)gs(n)
</code></pre>

<h5 id="mysql-21">MySQL</h5>

<p>MySQL не поддерживает функцию для автоматического формирования строк.</p>

<h3 id="12-составление-отчетов-и-управление-хранилищами-данных-стр-420">12 Составление отчетов и управление хранилищами данных (стр. 420)</h3>

<h4 id="разворачивание-результирующего-множества-в-одну-строку-стр-420">Разворачивание результирующего множества в одну строку (стр. 420)</h4>

<pre><code class="language-SQL">  select sum(case when deptno=10 then 1 else 0 end) as deptno_10,
    sum(case when deptno=20 then 1 else 0 end) as deptno_20,
    sum(case when deptno=30 then 1 else 0 end) as deptno_30
  from emp
</code></pre>

<pre><code class="language-SQL">  select max(case when deptno=10 then empcount else null end) as deptno_10
    max(case when deptno=20 then empcount else null end) as deptno_20,
    max(case when deptno=30 then empcount else null end) as deptno_30
  from (
    select deptno, count(*) as empcount
    from emp
    group by deptno
  ) x
</code></pre>

<h4 id="разворачивание-результирующего-множества-в-несколько-строк-стр-423">Разворачивание результирующего множества в несколько строк (стр. 423)</h4>

<pre><code class="language-SQL">  select 
    max(case when job='CLERK'
      then ename else null end) as clerks,
    max(case when job='ANALYST'
      then ename else null end) as analysts,
    max(case when job='MANAGER'
      then ename else null end) as mgrs,
    max(case when job='PRESIDENT'
      then ename else null end) as prez,
    max(case when job='SALESMAN'
      then ename else null end) as sales
  from (
    select e.job,
      e.ename,
      (select count(*) from emp d
      where e.job=d.job and e.empno &lt; d.empno) as rnk
      from emp e
    ) x
  group by rnk
</code></pre>

<h4 id="обратное-разворачивание-результирующего-множества-стр-431">Обратное разворачивание результирующего множества (стр. 431)</h4>

<pre><code class="language-SQL">  select dept.deptno,
    case dept.deptno
      when 10 then emp_cnts.deptno_10
      when 20 then emp_cnts.deptno_20
      when 30 then emp_cnts.deptno_30
    end as counts_by_dept
  from (
    select sum(case when deptno=10 then 1 else 0 end) as deptno_10,
      sum(case when deptno=20 then 1 else 0 end) as deptno_20,
      sum(case when deptno=30 then 1 else 0 end) as deptno_30
    from emp
  ) emp_cnts,
  (select deptno from dept where deptno &lt;= 30) dept
</code></pre>

<h4 id="обратное-разворачивание-результирующего-множества-в-один-столбец-стр-433">Обратное разворачивание результирующего множества в один столбец (стр. 433)</h4>

<h5 id="db2-oracle-и-sql-server-2">DB2, Oracle и SQL Server</h5>

<pre><code class="language-SQL">  select case rn
    when 1 then ename
    when 2 then job
    when 3 then cast(sal as char(4))
  end emps
  from (
    select e.ename,e.job,e.sal,
      row_number()over(partition by e.empno
    order by e.empno) rn
    from emp e,
    (select *
    from emp where job='CLERK') four_rows
    where e.deptno=10
  ) x
</code></pre>

<h5 id="postgresql-и-mysql">PostgreSQL и MySQL</h5>

<p>Данный рецепт призван обратить внимание на применение ранжирующих функций для ранжирования строк,
которое затем используется при разворачивании таблицы. На момент написания данной книги ни PostgreSQL, ни MySQL не поддерживают ранжирующие функции.</p>

<h4 id="разворачивание-результирующего-множества-для-упрощения-вычислений-стр-440">Разворачивание результирующего множества для упрощения вычислений (стр. 440)</h4>

<pre><code class="language-SQL">  select d20_sal - d10_sal as d20_10_diff,
    d20_sal - d30_sal as d20_30_diff
  from (
    select sum(case when deptno=10 then sal end) as d10_sal,
      sum(case when deptno=20 then sal end) as d20_sal,
      sum(case when deptno=30 then sal end) as d30_sal
    from emp
  ) totals_by_dept
</code></pre>

<h4 id="создание-блоков-данных-фиксированного-размера-стр-441">Создание блоков данных фиксированного размера (стр. 441)</h4>

<h5 id="db2-oracle-и-sql-server-3">DB2, Oracle и SQL Server</h5>

<pre><code class="language-SQL">  select ceil(row_number()over(order by empno)/5.0) grp, empno, ename from emp
</code></pre>
<h5 id="postgresql-и-mysql-1">PostgreSQL и MySQL</h5>

<pre><code class="language-SQL">  select ceil(rnk/5.0) as grp, empno, ename
  from (
    select e.empno, e.ename,
    (select count(*) from emp d
    where e.empno &lt; d.empno)+1 as rnk
    from emp e
  ) x
  order by grp
</code></pre>

<h4 id="создание-заданного-количества-блоков-стр-445">Создание заданного количества блоков (стр. 445)</h4>

<h5 id="oracle-и-sql-server">Oracle и SQL Server</h5>

<pre><code class="language-SQL">  select ntile(4)over(order by empno) grp, empno, ename from emp
</code></pre>

<h5 id="mysql-и-postgresql-2">MySQL и PostgreSQL</h5>

<pre><code class="language-SQL">  select mod(count(*),4)+1 as grp,e.empno,e.ename
  from emp e, emp d
  where e.empno &gt;= d.empno
  group by e.empno,e.ename
  order by 1
</code></pre>

<h4 id="создание-горизонтальных-гистограмм-стр-451">Создание горизонтальных гистограмм (стр. 451)</h4>

<h5 id="oracle-postgresql-и-mysql">Oracle, PostgreSQL и MySQL</h5>

<pre><code class="language-SQL">  select deptno, lpad('*',count(*),'*') as cnt
  from emp
  group by deptno 
</code></pre>

<h4 id="создание-вертикальных-гистограмм-стр-453">Создание вертикальных гистограмм (стр. 453)</h4>

<h5 id="postgresql-и-mysql-2">PostgreSQL и MySQL</h5>

<pre><code class="language-SQL">  select max(deptno_10) as d10,
    max(deptno_20) as d20,
    max(deptno_30) as d30
  from (
    select case when e.deptno=10 then '*' else null end deptno_10,
      case when e.deptno=20 then '*' else null end deptno_20,
      case when e.deptno=30 then '*' else null end deptno_30,
      (select count(*) from emp d
      where e.deptno=d.deptno and e.empno &lt; d.empno ) as rnk
    from emp e
  ) x
  group by rnk
  order by 1 desc, 2 desc, 3 desc
</code></pre>

<h4 id="как-возвратить-столбцы-не-перечисленные-в-операторе-group-by-стр-456">Как возвратить столбцы, не перечисленные в операторе GROUP BY (стр. 456)</h4>

<pre><code class="language-SQL">  select deptno,ename,job,sal,
    case when sal = max_by_dept
      then 'TOP SAL IN DEPT'
    when sal = min_by_dept
      then 'LOW SAL IN DEPT'
    end as dept_status,
    case when sal = max_by_job
      then 'TOP SAL IN JOB'
    when sal = min_by_job
      then 'LOW SAL IN JOB'
    end as job_status
  from (
    select e.deptno,e.ename,e.job,e.sal,
      (select max(sal) from emp d
      where d.deptno = e.deptno) as max_by_dept,
      (select max(sal) from emp d
      where d.job = e.job) as max_by_job,
      (select min(sal) from emp d
      where d.deptno = e.deptno) as min_by_dept,
      (select min(sal) from emp d
      where d.job = e.job) as min_by_job
    from emp e
  ) x
  where sal in (max_by_dept,max_by_job,
  min_by_dept,min_by_job)
</code></pre>

<h4 id="вычисление-простых-подсумм-стр-462">Вычисление простых подсумм (стр. 462)</h4>

<p>В данном рецепте под «простой подсуммой» подразумевается результирующее множество, содержащее значения, полученные в результате агрегации одного столбца, и общую сумму таблицы.</p>

<pre><code class="language-SQL">  select coalesce(job,'TOTAL') job,
  sum(sal) sal
  from emp
  group by job with rollup
</code></pre>

<h4 id="вычисление-подсумм-для-всех-возможных-сочетаний-стр-466">Вычисление подсумм для всех возможных сочетаний (стр. 466)</h4>

<pre><code class="language-SQL">  select deptno, job, 'TOTAL BY DEPT AND JOB' as category, sum(sal) as sal
  from emp
  group by deptno, job

  union all

  select null, job, 'TOTAL BY JOB', sum(sal)
  from emp
  group by job

  union all

  select deptno, null, 'TOTAL BY DEPT', sum(sal)
  from emp
  group by deptno

  union all

  select null,null,'GRAND TOTAL FOR TABLE', sum(sal)
  from emp
</code></pre>

<h4 id="использование-выражений-case-для-маркировки-строк-стр-478">Использование выражений <code class="highlighter-rouge">CASE</code> для маркировки строк (стр. 478)</h4>

<pre><code class="language-SQL">  select ename,
    case when job = 'CLERK'
      then 1 else 0
    end as is_clerk,
    case when job = 'SALESMAN'
      then 1 else 0
    end as is_sales,
    case when job = 'MANAGER'
      then 1 else 0
    end as is_mgr,
    case when job = 'ANALYST'
      then 1 else 0
    end as is_analyst,
    case when job = 'PRESIDENT'
      then 1 else 0
    end as is_prez
  from emp
  order by 2,3,4,5,6
</code></pre>

<h4 id="создание-разреженной-матрицы-стр-480">Создание разреженной матрицы (стр. 480)</h4>

<pre><code class="language-SQL">  select case deptno when 10 then ename end as d10,
    case deptno when 20 then ename end as d20,
    case deptno when 30 then ename end as d30,
    case job when 'CLERK' then ename end as clerks,
    case job when 'MANAGER' then ename end as mgrs,
    case job when 'PRESIDENT' then ename end as prez,
    case job when 'ANALYST' then ename end as anals,
    case job when 'SALESMAN' then ename end as sales
  from emp
</code></pre>

<h4 id="группировка-строк-по-интервалам-времени-стр-481">Группировка строк по интервалам времени (стр. 481)</h4>

<pre><code class="language-SQL">  select ceil(trx_id/5.0) as grp,
    min(trx_date) as trx_start,
    max(trx_date) as trx_end,
    sum(trx_cnt) as total
  from trx_log
  group by ceil(trx_id/5.0)
</code></pre>

<h4 id="агрегация-разных-группсегментов-одновременно-стр-485">Агрегация разных групп/сегментов одновременно (стр. 485)</h4>

<pre><code class="language-SQL">  select e.ename,
    e.deptno,
    (select count(*) from emp d
    where d.deptno = e.deptno) as deptno_cnt,
    job,
    (select count(*) from emp d
    where d.job = e.job) as job_cnt,
    (select count(*) from emp) as total
  from emp e
</code></pre>

<h4 id="агрегация-скользящего-множества-значений-стр-487">Агрегация скользящего множества значений (стр. 487)</h4>

<pre><code class="language-SQL">  select e.hiredate,e.sal,
    (select sum(sal) from emp d
  where d.hiredate between e.hiredate90
    and e.hiredate) as spending_pattern
  from emp e
  order by 1
</code></pre>

<h3 id="иерархические-запросы-стр-500">Иерархические запросы (стр. 500)</h3>

<h4 id="представление-отношений-родительпотомок-стр-501">Представление отношений родительпотомок (стр. 501)</h4>

<pre><code class="language-SQL">  select concat(a.ename, ' works for ',b.ename) as emps_and_mgrs
  from emp a, emp b
  where a.mgr = b.empno
</code></pre>

<h4 id="представление-отношений-потомокродительпрародитель-стр-505">Представление отношений потомокродительпрародитель (стр. 505)</h4>

<pre><code class="language-SQL">  select a.ename||'&gt;'||b.ename||'&gt;'||c.ename as leaf___branch___root
  from emp a, emp b, emp c
  where a.ename = 'MILLER'
  and a.mgr = b.empno
  and b.mgr = c.empno
</code></pre>

<h4 id="создание-иерархического-представления-таблицы-стр-510">Создание иерархического представления таблицы (стр. 510)</h4>

<h5 id="mysql-22">MySQL</h5>

<pre><code class="language-SQL">  select emp_tree
  from (
    select ename as emp_tree
    from emp
    where mgr is null

  union

  select concat(a.ename,'  ',b.ename)
  from emp a
  join
    emp b on (a.empno=b.mgr)
  where a.mgr is null

  union

  select concat(a.ename,'  ',b.ename,'  ',c.ename)
  from emp a
  join
    emp b on (a.empno=b.mgr)
  left join
    emp c on (b.empno=c.mgr)
  where a.ename = 'KING'

  union

  select concat(a.ename,'  ',b.ename,'  ',c.ename,'  ',d.ename)
  from emp a
  join
    emp b on (a.empno=b.mgr)
  join
    emp c on (b.empno=c.mgr)
  left join
    emp d on (c.empno=d.mgr)
  where a.ename = 'KING'
  ) x
  where tree is not null
  order by 1
</code></pre>

<h4 id="выбор-всех-дочерних-строк-для-заданной-строки-стр-519">Выбор всех дочерних строк для заданной строки (стр. 519)</h4>

<pre><code class="language-SQL">/* находим EMPNO служащего JONES */
select ename,empno,mgr
from emp
where ename = 'JONES'
</code></pre>

<table>
  <thead>
    <tr>
      <th>ENAME</th>
      <th>EMPNO</th>
      <th>MGR</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JONES</td>
      <td>7566</td>
      <td>7839</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-SQL">/* есть ли служащие, находящиеся в прямом подчинении у JONES? */
select count(*)
from emp
where mgr = 7566
</code></pre>

<table>
  <thead>
    <tr>
      <th>COUNT(*)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-SQL">/* у JONES двое подчиненных, найдем их EMPNO */
select ename,empno,mgr
from emp
where mgr = 7566
</code></pre>
<p>ENAME | EMPNO | MGR
—– | —– | —<br />
SCOTT | 7788 | 7566
FORD | 7902 | 7566</p>

<pre><code class="language-SQL">/* есть ли подчиненные у SCOTT или FORD? */
select count(*)
from emp
where mgr in (7788,7902)
</code></pre>

<table>
  <thead>
    <tr>
      <th>COUNT(*)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-SQL">/* у SCOTT и FORD двое подчиненных, находим их EMPNO */
select ename,empno,mgr
from emp
where mgr in (7788,7902)
</code></pre>

<table>
  <thead>
    <tr>
      <th>ENAME</th>
      <th>EMPNO</th>
      <th>MGR</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SMITH</td>
      <td>7369</td>
      <td>7902</td>
    </tr>
    <tr>
      <td>ADAMS</td>
      <td>7876</td>
      <td>7788</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-SQL">/* есть ли подчиненные у SMITH или ADAMS? */
select count(*)
from emp
where mgr in (7369,7876)
</code></pre>

<table>
  <thead>
    <tr>
      <th>COUNT(*)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Теперь, когда известна глубина, можно приступать к обходу иерархии сверху вниз. Сначала дважды выполним рефлексивное объединение таблицы EMP. Затем произведем обратное разворачивание вложенного представления Х, чтобы преобразовать три столбца и две строки в один столбец и шесть строк</p>

<pre><code class="language-SQL">  select distinct
    case t100.id
      when 1 then root
      when 2 then branch
      else leaf
    end as JONES_SUBORDINATES
  from (
    select a.ename as root,
      b.ename as branch,
      c.ename as leaf
    from emp a, emp b, emp c
    where a.ename = 'JONES'
      and a.empno = b.mgr
      and b.empno = c.mgr
  ) x,
  t100
  where t100.id &lt;= 6
</code></pre>

<h4 id="определение-узлов-ветвления-концевого-корневого-стр-523">Определение узлов: ветвления, концевого, корневого (стр. 523)</h4>

<pre><code class="language-SQL">select e.ename,
  (select sign(count(*)) from emp d
    where 0 =
    (select count(*) from emp f
    where f.mgr = e.empno)) as is_leaf,
  (select sign(count(*)) from emp d
  where d.mgr = e.empno
    and e.mgr is not null) as is_branch,
  (select sign(count(*)) from emp d
  where d.empno = e.empno
    and d.mgr is null) as is_root
  from emp e
  order by 4 desc,3 desc
</code></pre>

<h3 id="14-всякая-всячина--стр-532">14 Всякая всячина  (стр. 532)</h3>

<h4 id="создание-отчетов-с-перекрестными-ссылками-с-помощью-оператора-sql-server-pivot-стр-532">Создание отчетов с перекрестными ссылками с помощью оператора SQL Server <code class="highlighter-rouge">PIVOT</code> (стр. 532)</h4>

<pre><code class="language-SQL">  select [10] as dept_10,
    [20] as dept_20,
    [30] as dept_30,
    [40] as dept_40
  from (select deptno, empno from emp) driver
  pivot (
    count(driver.empno)
    for driver.deptno in ( [10],[20],[30],[40] )
  ) as empPivot
</code></pre>

<h4 id="обратное-разворачивание-отчета-с-помощью-оператора-sql-server-unpivot-стр-534">Обратное разворачивание отчета с помощью оператора SQL Server <code class="highlighter-rouge">UNPIVOT</code> (стр. 534)</h4>

<pre><code class="language-SQL">  select DNAME, CNT
  from (
    select [ACCOUNTING] as ACCOUNTING,
      [SALES] as SALES,
      [RESEARCH] as RESEARCH,
      [OPERATIONS] as OPERATIONS
    from (
      select d.dname, e.empno
      from emp e,dept d
      where e.deptno=d.deptno
 
  ) driver
  pivot (
    count(driver.empno)
    for driver.dname in
     ([ACCOUNTING],[SALES],[RESEARCH],[OPERATIONS])
  ) as empPivot
  ) new_driver
  unpivot (cnt for dname in (ACCOUNTING,SALES,RESEARCH,OPERATIONS)
  ) as un_pivot
</code></pre>

  </div><a class="u-url" href="/instamart-academic-plan/2018/11/11/mollinaro-coockbook.html" hidden></a>
</article>

      </div>
    </main>

  </body>

</html>
